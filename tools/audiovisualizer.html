<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.U.S.P.E.C.T. Smooth Capture</title>
    <style>
        :root {
            --bg-main: #1a1a1a;
            --accent: #00d4ff;
            --border: #2a2a2a;
            --panel: rgba(25, 25, 25, 0.9);
        }

        body { background: var(--bg-main); color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; image-rendering: pixelated; }

        .hud-sidebar {
            position: fixed; top: 20px; left: 20px; width: 280px;
            background: var(--panel); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-left: 3px solid var(--accent);
            padding: 20px; z-index: 100; border-radius: 4px;
        }

        h2 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); margin: 0 0 15px 0; }
        label { font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin-bottom: 5px; }
        
        input, select, button { 
            background: #111; border: 1px solid var(--border); color: white; 
            padding: 8px; border-radius: 3px; font-size: 0.85rem; width: 100%; margin-bottom: 12px;
        }
        
        button { 
            cursor: pointer; font-weight: bold; text-transform: uppercase; 
            border-left: 3px solid var(--accent); transition: 0.2s; 
        }
        button:hover:not(:disabled) { background: #222; border-color: white; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }

        #dlBtn { border-left-color: #28a745; display: none; }
        #statusBox { font-size: 0.7rem; color: var(--accent); font-family: monospace; }
        
        .rec-dot { 
            display: inline-block; width: 8px; height: 8px; background: #ff4444; 
            border-radius: 50%; margin-right: 5px; visibility: hidden;
        }
        .recording .rec-dot { visibility: visible; animation: blink 1s infinite; }
        @keyframes blink { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div class="hud-sidebar" id="hud">
        <h2>Capture Terminal</h2>
        
        <label>Audio Data</label>
        <input type="file" id="audioFile" accept="audio/*">

        <label>Visual Algorithm</label>
        <select id="visualizerStyle">
            <option value="bars">Frequency Columns</option>
            <option value="wave">Oscilloscope</option>
            <option value="circles">Radial Pulse</option>
        </select>

        <label>HUD Accent</label>
        <input type="color" id="barColor" value="#00d4ff">

        <audio id="audio" controls style="height: 30px; margin-bottom: 15px;"></audio>

        <button id="startBtn">Initialize Capture</button>
        <button id="stopBtn" disabled>Terminate</button>
        <button id="dlBtn">Download WebM</button>

        <div id="statusBox"><span class="rec-dot"></span><span id="statText">System Ready</span></div>
    </div>

    <canvas id="visualizer"></canvas>

    <script>
        const audio = document.getElementById("audio");
        const canvas = document.getElementById("visualizer");
        const ctx = canvas.getContext("2d", { alpha: false }); // Performance boost: disable alpha
        const statusText = document.getElementById("statText");
        const hud = document.getElementById("hud");

        const startBtn = document.getElementById("startBtn");
        const stopBtn = document.getElementById("stopBtn");
        const dlBtn = document.getElementById("dlBtn");

        let audioCtx, analyser, source, bufferLength, dataArray;
        let mediaRecorder, recordedChunks = [];
        let finalBlob;

        // Potato Optimization: Set a specific resolution
        // Higher resolution = more lag. 1280x720 is the "Pro" sweet spot.
        function setResolution() {
            canvas.width = 1280;
            canvas.height = 720;
        }
        setResolution();

        document.getElementById("audioFile").onchange = (e) => {
            if (e.target.files[0]) audio.src = URL.createObjectURL(e.target.files[0]);
        };

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            source = audioCtx.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            analyser.fftSize = 256;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
            draw();
        }

        function draw() {
            requestAnimationFrame(draw);
            analyser.getByteFrequencyData(dataArray);
            
            // Performance: Using a solid color background instead of clearRect
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const color = document.getElementById("barColor").value;
            const style = document.getElementById("visualizerStyle").value;
            
            ctx.fillStyle = color;
            ctx.strokeStyle = color;
            ctx.lineWidth = 4;

            if (style === "bars") {
                const barWidth = canvas.width / bufferLength;
                for (let i = 0; i < bufferLength; i++) {
                    const h = (dataArray[i] / 255) * canvas.height;
                    ctx.fillRect(i * barWidth, canvas.height - h, barWidth - 1, h);
                }
            } else if (style === "wave") {
                ctx.beginPath();
                const sw = canvas.width / bufferLength;
                for (let i = 0; i < bufferLength; i++) {
                    const y = (dataArray[i] / 255) * canvas.height;
                    if (i === 0) ctx.moveTo(0, y); else ctx.lineTo(i * sw, y);
                }
                ctx.stroke();
            } else if (style === "circles") {
                const cx = canvas.width / 2;
                const cy = canvas.height / 2;
                for (let i = 0; i < bufferLength; i += 4) {
                    const r = (dataArray[i] / 255) * (canvas.height / 2);
                    ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.stroke();
                }
            }
        }

        audio.onended = () => { if (mediaRecorder?.state === "recording") endCapture(); };

        startBtn.onclick = () => {
            initAudio();
            recordedChunks = [];
            dlBtn.style.display = "none";
            
            // PRO POTATO TIP: Capture at 30FPS for stability on weak CPUs
            // Most "pro" video is 24 or 30fps anyway. 60fps kills potatoes.
            const stream = canvas.captureStream(30); 
            
            const audioStream = audio.captureStream ? audio.captureStream() : audio.mozCaptureStream();
            audioStream.getAudioTracks().forEach(track => stream.addTrack(track));

            // Codec Optimization: VP8 is much lighter on old CPUs than VP9
            mediaRecorder = new MediaRecorder(stream, { 
                mimeType: "video/webm;codecs=vp8",
                videoBitsPerSecond: 8000000 // 8Mbps high-def
            });

            mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
            mediaRecorder.onstop = () => {
                finalBlob = new Blob(recordedChunks, { type: "video/webm" });
                dlBtn.style.display = "block";
                statusText.innerText = "Data Stored.";
            };

            mediaRecorder.start(100); // Timeslice of 100ms helps keep memory clear
            audio.currentTime = 0;
            audio.play();
            
            startBtn.disabled = true; stopBtn.disabled = false;
            hud.classList.add("recording");
            statusText.innerText = "Recording...";
        };

        function endCapture() {
            mediaRecorder.stop();
            audio.pause();
            startBtn.disabled = false; stopBtn.disabled = true;
            hud.classList.remove("recording");
            statusText.innerText = "Capture Interrupted.";
        }

        stopBtn.onclick = endCapture;

        dlBtn.onclick = () => {
            const a = document.createElement("a");
            a.href = URL.createObjectURL(finalBlob);
            a.download = "SUSPECT_SMOOTH_RENDER.webm";
            a.click();
        };
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.U.S.P.E.C.T. Precision Renderer</title>
    <style>
        :root { --bg: #1a1a1a; --accent: #00d4ff; --border: #2a2a2a; }
        body { background: var(--bg); color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; background: #1a1a1a; }

        .hud-sidebar {
            position: fixed; top: 20px; left: 20px; width: 280px;
            background: rgba(25, 25, 25, 0.95); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-left: 3px solid var(--accent);
            padding: 20px; z-index: 100; border-radius: 4px; box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        h2 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); margin: 0 0 15px 0; }
        label { font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin: 8px 0 4px 0; }
        input, select, button { background: #111; border: 1px solid var(--border); color: white; padding: 8px; border-radius: 3px; font-size: 0.85rem; width: 100%; margin-bottom: 10px; outline: none; }
        
        button { cursor: pointer; font-weight: bold; text-transform: uppercase; border-left: 3px solid var(--accent); transition: 0.2s; }
        button:hover:not(:disabled) { background: #222; border-color: white; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        
        #statusBox { font-size: 0.7rem; color: var(--accent); font-family: monospace; margin-top: 10px; min-height: 1.2em; }
        .progress-bar { width: 100%; height: 4px; background: #333; display: none; margin-top: 10px; border-radius: 2px; overflow: hidden; }
        #progressFill { width: 0%; height: 100%; background: var(--accent); }
    </style>
</head>
<body>

    <div class="hud-sidebar">
        <h2>S.U.S.P.E.C.T. Terminal</h2>
        
        <label>Audio Source</label>
        <input type="file" id="audioFile" accept="audio/*">

        <label>Visual Algorithm</label>
        <select id="visualizerStyle">
            <option value="bars">Frequency Columns</option>
            <option value="wave">Oscilloscope</option>
            <option value="circles">Radial Pulse</option>
        </select>

        <label>Accent Color</label>
        <input type="color" id="barColor" value="#00d4ff">

        <audio id="audio" controls style="height: 30px; margin-bottom: 15px;"></audio>

        <button id="previewBtn">Live Preview</button>
        <button id="renderBtn" disabled style="border-left-color: #ffb400;">Finalize & Render WebM</button>

        <div id="statusBox">SYSTEM READY</div>
        <div class="progress-bar" id="progBar"><div id="progressFill"></div></div>
    </div>

    <canvas id="visualizer"></canvas>

    <script>
        const audio = document.getElementById("audio");
        const canvas = document.getElementById("visualizer");
        const ctx = canvas.getContext("2d");
        const status = document.getElementById("statusBox");
        const renderBtn = document.getElementById("renderBtn");
        const progBar = document.getElementById("progBar");
        const progFill = document.getElementById("progressFill");

        let audioCtx, analyser, source, gainNode, bufferLength, dataArray;
        let isPreviewing = false;

        canvas.width = 1280; canvas.height = 720;

        document.getElementById("audioFile").onchange = (e) => {
            if (e.target.files[0]) {
                audio.src = URL.createObjectURL(e.target.files[0]);
                renderBtn.disabled = false;
                status.innerText = "DATA LOADED.";
            }
        };

        function setupAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            gainNode = audioCtx.createGain(); // The "Silent Render" knob
            
            source = audioCtx.createMediaElementSource(audio);
            
            // Connect Source -> Analyser (For visual data)
            source.connect(analyser);
            // Connect Analyser -> Gain (For hearing/muting)
            analyser.connect(gainNode);
            // Connect Gain -> Speakers
            gainNode.connect(audioCtx.destination);

            analyser.fftSize = 256;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        function drawFrame() {
            if (!isPreviewing && !window.isRendering) return;
            if (isPreviewing) requestAnimationFrame(drawFrame);
            
            analyser.getByteFrequencyData(dataArray);
            
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            const color = document.getElementById("barColor").value;
            const style = document.getElementById("visualizerStyle").value;
            
            ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = 4;
            ctx.shadowBlur = 10; ctx.shadowColor = color;

            if (style === "bars") {
                const bw = canvas.width / bufferLength;
                for (let i = 0; i < bufferLength; i++) {
                    const h = (dataArray[i] / 255) * canvas.height;
                    ctx.fillRect(i * bw, canvas.height - h, bw - 1, h);
                }
            } else if (style === "wave") {
                ctx.beginPath();
                const sw = canvas.width / bufferLength;
                for (let i = 0; i < bufferLength; i++) {
                    const y = (dataArray[i] / 255) * canvas.height;
                    if (i === 0) ctx.moveTo(0, y); else ctx.lineTo(i * sw, y);
                }
                ctx.stroke();
            } else if (style === "circles") {
                for (let i = 0; i < bufferLength; i += 4) {
                    const r = (dataArray[i] / 255) * (canvas.height / 2.5);
                    ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, r, 0, Math.PI*2); ctx.stroke();
                }
            }
            ctx.shadowBlur = 0;
        }

        document.getElementById("previewBtn").onclick = () => {
            setupAudio();
            isPreviewing = true;
            gainNode.gain.value = 1; // Unmute
            audio.play();
            drawFrame();
            status.innerText = "PREVIEWING...";
        };

        renderBtn.onclick = async () => {
            setupAudio();
            isPreviewing = false;
            window.isRendering = true;
            renderBtn.disabled = true;
            progBar.style.display = "block";
            
            audio.currentTime = 0;
            gainNode.gain.value = 0; // MUTE SPEAKERS BUT KEEP DATA FLOWING

            const stream = canvas.captureStream(30);
            const audioDest = audioCtx.createMediaStreamDestination();
            
            // Connect the analyser to the recorder so the video has sound
            analyser.connect(audioDest);
            stream.addTrack(audioDest.stream.getAudioTracks()[0]);

            const recorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp8,opus', 
                videoBitsPerSecond: 10000000 
            });

            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            
            recorder.onstop = () => {
                status.innerText = "FINALIZING...";
                setTimeout(() => {
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement("a");
                    a.href = url;
                    a.download = `S_U_S_P_E_C_T_Render.webm`;
                    a.click();
                    
                    status.innerText = "DOWNLOAD READY.";
                    progBar.style.display = "none";
                    renderBtn.disabled = false;
                    window.isRendering = false;
                    gainNode.gain.value = 1; // Reset volume for user
                }, 500);
            };

            recorder.start();
            audio.play();

            const renderLoop = setInterval(() => {
                drawFrame();
                const pct = (audio.currentTime / audio.duration) * 100;
                progFill.style.width = pct + "%";
                status.innerText = `ENCODING: ${Math.round(pct)}%`;

                if (audio.ended) {
                    clearInterval(renderLoop);
                    recorder.stop();
                }
            }, 1000 / 30);
        };
    </script>
	v2
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.U.S.P.E.C.T. Precision Renderer</title>
    <style>
        :root { --bg: #1a1a1a; --accent: #00d4ff; --border: #2a2a2a; }
        body { background: var(--bg); color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; background: #1a1a1a; }

        .hud-sidebar {
            position: fixed; top: 20px; left: 20px; width: 280px;
            background: rgba(25, 25, 25, 0.95); backdrop-filter: blur(10px);
            border: 1px solid var(--border); border-left: 3px solid var(--accent);
            padding: 20px; z-index: 100; border-radius: 4px;
        }

        h2 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); margin: 0 0 15px 0; }
        label { font-size: 0.65rem; color: #888; text-transform: uppercase; display: block; margin: 8px 0 4px 0; }
        input, select, button { background: #111; border: 1px solid var(--border); color: white; padding: 8px; border-radius: 3px; font-size: 0.85rem; width: 100%; margin-bottom: 10px; outline: none; }
        
        button { cursor: pointer; font-weight: bold; text-transform: uppercase; border-left: 3px solid var(--accent); transition: 0.2s; }
        button:hover:not(:disabled) { background: #222; border-color: white; }
        button:disabled { opacity: 0.3; cursor: not-allowed; }
        
        #statusBox { font-size: 0.7rem; color: var(--accent); font-family: monospace; margin-top: 10px; }
        .progress-bar { width: 100%; height: 4px; background: #333; display: none; margin-top: 10px; border-radius: 2px; overflow: hidden; }
        #progressFill { width: 0%; height: 100%; background: var(--accent); transition: width 0.1s; }
    </style>
</head>
<body>

    <div class="hud-sidebar">
        <h2>S.U.S.P.E.C.T. Terminal</h2>
        
        <label>Audio Data</label>
        <input type="file" id="audioFile" accept="audio/*">

        <label>Visual Algorithm</label>
        <select id="visualizerStyle">
            <option value="bars">Frequency Columns</option>
            <option value="wave">Oscilloscope</option>
            <option value="circles">Radial Pulse</option>
        </select>

        <label>HUD Accent</label>
        <input type="color" id="barColor" value="#00d4ff">

        <audio id="audio" controls style="height: 30px; margin-bottom: 15px;"></audio>

        <button id="previewBtn">Live Preview</button>
        <button id="renderBtn" disabled style="border-left-color: #ffb400;">Finalize & Render WebM</button>

        <div id="statusBox">SYSTEM READY</div>
        <div class="progress-bar" id="progBar"><div id="progressFill"></div></div>
    </div>

    <canvas id="visualizer"></canvas>

    <script>
        const audio = document.getElementById("audio");
        const canvas = document.getElementById("visualizer");
        const ctx = canvas.getContext("2d");
        const status = document.getElementById("statusBox");
        const renderBtn = document.getElementById("renderBtn");
        const progBar = document.getElementById("progBar");
        const progFill = document.getElementById("progressFill");

        let audioCtx, analyser, source, bufferLength, dataArray;
        let isPreviewing = false;

        // Optimized Resolution for WebM -> MP4 Conversion
        canvas.width = 1280; canvas.height = 720;

        document.getElementById("audioFile").onchange = (e) => {
            if (e.target.files[0]) {
                audio.src = URL.createObjectURL(e.target.files[0]);
                renderBtn.disabled = false;
                status.innerText = "DATA LOADED. READY.";
            }
        };

        function setupAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            source = audioCtx.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(audioCtx.destination);
            analyser.fftSize = 256;
            bufferLength = analyser.frequencyBinCount;
            dataArray = new Uint8Array(bufferLength);
        }

        function drawPreview() {
            if (!isPreviewing) return;
            requestAnimationFrame(drawPreview);
            analyser.getByteFrequencyData(dataArray);
            renderCanvas(dataArray);
        }

        function renderCanvas(data) {
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            const color = document.getElementById("barColor").value;
            const style = document.getElementById("visualizerStyle").value;
            ctx.fillStyle = color; ctx.strokeStyle = color; ctx.lineWidth = 4;
            ctx.shadowBlur = 8; ctx.shadowColor = color;

            if (style === "bars") {
                const bw = canvas.width / bufferLength;
                for (let i = 0; i < bufferLength; i++) {
                    const h = (data[i] / 255) * canvas.height;
                    ctx.fillRect(i * bw, canvas.height - h, bw - 1, h);
                }
            } else if (style === "wave") {
                ctx.beginPath();
                const sw = canvas.width / bufferLength;
                for (let i = 0; i < bufferLength; i++) {
                    const y = (data[i] / 255) * canvas.height;
                    if (i === 0) ctx.moveTo(0, y); else ctx.lineTo(i * sw, y);
                }
                ctx.stroke();
            } else if (style === "circles") {
                for (let i = 0; i < bufferLength; i += 4) {
                    const r = (data[i] / 255) * (canvas.height / 2.5);
                    ctx.beginPath(); ctx.arc(canvas.width/2, canvas.height/2, r, 0, Math.PI*2); ctx.stroke();
                }
            }
            ctx.shadowBlur = 0;
        }

        document.getElementById("previewBtn").onclick = () => {
            setupAudio();
            isPreviewing = true;
            audio.play();
            drawPreview();
            status.innerText = "PREVIEW MODE ACTIVE";
        };

        // --- HIGH PRECISION RENDERER ---
        renderBtn.onclick = async () => {
            audio.pause();
            isPreviewing = false;
            renderBtn.disabled = true;
            progBar.style.display = "block";
            status.innerText = "CALCULATING RENDERTREE...";

            // 1. Prepare Silent Offline Context
            const file = document.getElementById("audioFile").files[0];
            const arrayBuffer = await file.arrayBuffer();
            const offlineCtx = new OfflineAudioContext(2, 44100 * 600, 44100); 
            const decodedData = await offlineCtx.decodeAudioData(arrayBuffer);
            
            // 2. Setup Recording Stream
            const stream = canvas.captureStream(30); // Capture at steady 30fps
            const recorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp8', 
                videoBitsPerSecond: 12000000 // High 12Mbps bitrate
            });
            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const a = document.createElement("a");
                a.href = URL.createObjectURL(blob);
                a.download = "SUSPECT_HD_RENDER.webm";
                a.click();
                status.innerText = "RENDER COMPLETE.";
                renderBtn.disabled = false;
            };

            recorder.start();
            audio.muted = true;
            audio.playbackRate = 1.0; // Keep it at 1.0 for perfect frame timing
            audio.currentTime = 0;
            
            status.innerText = "STABILIZING STREAM...";
            
            // Start the actual "Recording" sequence
            audio.play();
            
            const renderInterval = setInterval(() => {
                const pct = (audio.currentTime / audio.duration) * 100;
                progFill.style.width = pct + "%";
                status.innerText = `ENCODING: ${Math.round(pct)}%`;

                if (audio.ended || audio.currentTime >= audio.duration) {
                    clearInterval(renderInterval);
                    recorder.stop();
                    audio.muted = false;
                }
            }, 100);
        };
    </script>
</body>
</html>
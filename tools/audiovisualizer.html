<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>S.U.S.P.E.C.T. v2.9</title>
    <style>
        :root { --bg: #0a0a0a; --accent: #00d4ff; --border: #222; --gold: #ffb400; }
        body { background: var(--bg); color: #eee; font-family: 'Segoe UI', sans-serif; margin: 0; overflow: hidden; }
        canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; z-index: 1; background: #000; }

        .hud-sidebar {
            position: fixed; top: 20px; left: 20px; width: 300px; height: 90vh; overflow-y: auto;
            background: rgba(10, 10, 10, 0.95); backdrop-filter: blur(15px);
            border: 1px solid var(--border); border-left: 3px solid var(--accent);
            padding: 20px; z-index: 100; border-radius: 4px; scrollbar-width: none;
        }

        .hud-hidden { opacity: 0; transform: translateX(-380px); pointer-events: none; }
        h2 { font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px; color: var(--accent); margin: 0 0 15px 0; border-bottom: 1px solid var(--border); }
        label { font-size: 0.6rem; color: #888; text-transform: uppercase; display: block; margin: 10px 0 4px 0; }
        input, select, button { background: #111; border: 1px solid var(--border); color: white; padding: 8px; border-radius: 3px; font-size: 0.8rem; width: 100%; margin-bottom: 8px; outline: none; }
        
        .toggle-group { display: flex; align-items: center; gap: 8px; font-size: 0.65rem; color: var(--gold); margin: 5px 0; }
        .toggle-group input { width: auto; margin: 0; }

        button { cursor: pointer; font-weight: bold; text-transform: uppercase; border-left: 3px solid var(--accent); transition: 0.2s; }
        button:hover { background: #222; }
        #renderBtn { border-left-color: var(--gold); }
        #downloadWebmBtn { border-left-color: #28a745; display: none; }
        #renderOverlay { position: fixed; bottom: 20px; right: 20px; z-index: 1000; background: rgba(0,0,0,0.9); padding: 15px; border: 1px solid var(--accent); display: none; font-family: monospace; }
    </style>
</head>
<body>

    <div id="renderOverlay">KINETIC RENDER: <span id="overlayPct">0%</span></div>

    <div class="hud-sidebar" id="sidebar">
        <h2>S.U.S.P.E.C.T. v2.9</h2>
        
        <label>Media</label>
        <input type="file" id="audioFile" accept="audio/*">
        <input type="file" id="bgFile" accept="image/*">
        <input type="file" id="logoFile" accept="image/*">

        <label>Algorithm Selection</label>
        <select id="visualizerStyle">
            <option value="bars">Digital Columns</option>
            <option value="waveLines">Kinetic Wave Lines</option>
            <option value="spin">Rotational Data Spin</option>
            <option value="circles">Radial Engine</option>
            <option value="symmetry">Symmetry Bars</option>
            <option value="particles">Floating Particles</option>
        </select>

        <label>Chroma Profile</label>
        <div style="display:flex; gap:5px;">
            <input type="color" id="color1" value="#00d4ff">
            <input type="color" id="color2" value="#ff00ff">
        </div>

        <label>Wonk & Logo Scale</label>
        <div style="display:flex; gap:5px;">
            <input type="range" id="wonkSlider" min="0.5" max="4.0" step="0.1" value="1.0">
            <input type="range" id="logoSize" min="50" max="500" value="200">
        </div>

        <div class="toggle-group">
            <input type="checkbox" id="bassShake" checked>
            <label for="bassShake">CAMERA BASS SHAKE</label>
        </div>

        <div class="toggle-group">
            <input type="checkbox" id="logoPulse" checked>
            <label for="logoPulse">LOGO PULSE</label>
        </div>

        <div class="toggle-group">
            <input type="checkbox" id="hiPerfToggle" checked>
            <label for="hiPerfToggle">DEEP RENDER (FAST CONVERT)</label>
        </div>

        <audio id="audio" controls style="height: 30px; margin-top: 10px;"></audio>
        <button id="previewBtn">Preview</button>
        <button id="renderBtn" disabled>Render Compatible WebM</button>
        <button id="downloadWebmBtn">Download Master</button>
    </div>

    <canvas id="visualizer"></canvas>

    <script>
        const audio = document.getElementById("audio");
        const canvas = document.getElementById("visualizer");
        const ctx = canvas.getContext("2d", { alpha: false });
        
        let audioCtx, analyser, source, gainNode, dataArray;
        let isPreviewing = false;
        let finalBlobUrl = null;
        let bgImg = new Image();
        let logoImg = new Image();
        let particles = [];
        let rotationAngle = 0;

        canvas.width = 1280; canvas.height = 720;

        for(let i=0; i<50; i++) particles.push({ x: Math.random()*canvas.width, y: Math.random()*canvas.height, s: Math.random()*2+1 });

        document.getElementById("audioFile").onchange = (e) => { audio.src = URL.createObjectURL(e.target.files[0]); document.getElementById("renderBtn").disabled = false; };
        document.getElementById("bgFile").onchange = (e) => { bgImg.src = URL.createObjectURL(e.target.files[0]); };
        document.getElementById("logoFile").onchange = (e) => { logoImg.src = URL.createObjectURL(e.target.files[0]); };

        function setupAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioCtx.createAnalyser();
            gainNode = audioCtx.createGain();
            source = audioCtx.createMediaElementSource(audio);
            source.connect(analyser);
            analyser.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            analyser.fftSize = 512;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
        }

        function drawFrame() {
            analyser.getByteFrequencyData(dataArray);
            let sum = 0;
            for(let i=0; i<15; i++) sum += dataArray[i];
            let bass = sum / 15 / 255;
            const wonk = parseFloat(document.getElementById("wonkSlider").value);

            ctx.save();
            if (document.getElementById("bassShake").checked && bass > 0.6) {
                let intensity = (bass - 0.6) * 20;
                ctx.translate(Math.random()*intensity - intensity/2, Math.random()*intensity - intensity/2);
            }

            if (bgImg.src) {
                ctx.drawImage(bgImg, 0, 0, canvas.width, canvas.height);
                ctx.fillStyle = "rgba(0,0,0,0.7)"; ctx.fillRect(0, 0, canvas.width, canvas.height);
            } else {
                ctx.fillStyle = '#050505'; ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            const c1 = document.getElementById("color1").value;
            const c2 = document.getElementById("color2").value;
            const gradient = ctx.createLinearGradient(0, canvas.height, 0, 0);
            gradient.addColorStop(0, c1); gradient.addColorStop(1, c2);
            ctx.fillStyle = gradient; ctx.strokeStyle = gradient; ctx.lineWidth = 4;

            const style = document.getElementById("visualizerStyle").value;
            const bufferLength = dataArray.length;

            if (style === "bars") {
                const bw = canvas.width / (bufferLength / 2);
                for (let i = 0; i < bufferLength / 2; i++) {
                    let val = Math.pow(dataArray[i] / 255, wonk);
                    ctx.fillRect(i * bw, canvas.height, bw - 2, -val * canvas.height * 0.8);
                }
            } else if (style === "waveLines") {
                ctx.beginPath();
                const sw = canvas.width / (bufferLength / 2);
                for (let i = 0; i < bufferLength / 2; i++) {
                    let val = Math.pow(dataArray[i] / 255, wonk);
                    let y = (canvas.height / 2) + (val * 300 * (i % 2 === 0 ? 1 : -1));
                    if (i === 0) ctx.moveTo(0, y); else ctx.lineTo(i * sw, y);
                }
                ctx.stroke();
            } else if (style === "spin") {
                ctx.translate(canvas.width / 2, canvas.height / 2);
                rotationAngle += 0.01 + (bass * 0.1); // Spin velocity synced to bass
                ctx.rotate(rotationAngle);
                const bw = 4;
                for (let i = 0; i < bufferLength / 2; i++) {
                    let val = Math.pow(dataArray[i] / 255, wonk);
                    ctx.rotate((Math.PI * 2) / (bufferLength / 2));
                    ctx.fillRect(120, 0, val * 300, bw);
                }
                ctx.setTransform(1, 0, 0, 1, 0, 0);
                ctx.translate(canvas.width / 2, canvas.height / 2); // Re-center for logo
            } else if (style === "circles") {
                ctx.translate(canvas.width / 2, canvas.height / 2);
                for (let i = 0; i < bufferLength; i += 6) {
                    let val = Math.pow(dataArray[i] / 255, wonk);
                    ctx.beginPath(); ctx.arc(0, 0, val * 400, 0, Math.PI*2); ctx.stroke();
                }
            } else if (style === "symmetry") {
                ctx.translate(canvas.width / 2, canvas.height / 2);
                const bw = (canvas.width / 2) / (bufferLength / 4);
                for (let i = 0; i < bufferLength / 4; i++) {
                    let val = Math.pow(dataArray[i] / 255, wonk);
                    let h = val * canvas.height * 0.4;
                    ctx.fillRect(i * bw, 0, bw - 2, h); ctx.fillRect(i * bw, 0, bw - 2, -h);
                    ctx.fillRect(-i * bw, 0, bw - 2, h); ctx.fillRect(-i * bw, 0, bw - 2, -h);
                }
            } else if (style === "particles") {
                particles.forEach((p, i) => {
                    let val = Math.pow(dataArray[i % bufferLength] / 255, wonk);
                    p.y -= p.s + (val * 10);
                    if(p.y < 0) p.y = canvas.height;
                    ctx.beginPath(); ctx.arc(p.x, p.y, 2 + (val * 10), 0, Math.PI*2); ctx.fill();
                });
            }

            // Restore/Center for Logo
            if (style !== "spin" && style !== "circles" && style !== "symmetry") {
                ctx.translate(canvas.width / 2, canvas.height / 2);
            }
            
            if (logoImg.src) {
                const baseSize = parseInt(document.getElementById("logoSize").value);
                const finalSize = baseSize + (document.getElementById("logoPulse").checked ? (bass * 50) : 0);
                ctx.globalAlpha = 0.9;
                ctx.drawImage(logoImg, -finalSize/2, -finalSize/2, finalSize, finalSize);
                ctx.globalAlpha = 1.0;
            }
            ctx.restore();
        }

        function previewLoop() { if (isPreviewing) { drawFrame(); requestAnimationFrame(previewLoop); } }

        document.getElementById("previewBtn").onclick = () => { setupAudio(); isPreviewing = true; gainNode.gain.value = 1; audio.play(); previewLoop(); };

        document.getElementById("renderBtn").onclick = async () => {
            setupAudio(); isPreviewing = false;
            if (document.getElementById("hiPerfToggle").checked) document.getElementById("sidebar").classList.add("hud-hidden");
            document.getElementById("renderOverlay").style.display = "block";
            audio.currentTime = 0; gainNode.gain.value = 0;
            const stream = canvas.captureStream(30);
            const audioDest = audioCtx.createMediaStreamDestination();
            analyser.connect(audioDest);
            stream.addTrack(audioDest.stream.getAudioTracks()[0]);

            const recorder = new MediaRecorder(stream, { 
                mimeType: 'video/webm;codecs=vp8,opus', 
                videoBitsPerSecond: 12000000 
            });

            const chunks = [];
            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                finalBlobUrl = URL.createObjectURL(new Blob(chunks, { type: 'video/webm' }));
                document.getElementById("sidebar").classList.remove("hud-hidden");
                document.getElementById("renderOverlay").style.display = "none";
                document.getElementById("downloadWebmBtn").style.display = "block";
                gainNode.gain.value = 1;
            };
            recorder.start(1000); 
            audio.play();
            const renderLoop = setInterval(() => {
                drawFrame();
                const pct = Math.round((audio.currentTime / audio.duration) * 100);
                document.getElementById("overlayPct").innerText = pct + "%";
                if (audio.ended) { clearInterval(renderLoop); recorder.stop(); }
            }, 1000 / 30);
        };

        document.getElementById("downloadWebmBtn").onclick = () => {
            const a = document.createElement("a"); a.href = finalBlobUrl;
            a.download = `SUSPECT_v2.9_KINETIC.webm`; a.click();
        };
    </script>
</body>
</html>
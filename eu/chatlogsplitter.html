<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Entropia Log Manager</title>
    <style>
        body { font-family: 'Segoe UI', sans-serif; background: #121212; color: #eee; max-width: 700px; margin: 50px auto; }
        .box { background: #1e1e1e; padding: 30px; border-radius: 15px; border: 1px solid #333; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        h2 { color: #00aaff; margin-top: 0; text-align: center; }
        .setting-group { background: #252525; padding: 20px; border-radius: 8px; margin: 20px 0; border: 1px solid #444; }
        label { display: block; margin-bottom: 10px; font-weight: bold; color: #00aaff; }
        select, input[type="number"] { background: #333; color: white; border: 1px solid #555; padding: 8px; border-radius: 4px; width: 100%; box-sizing: border-box; }
        #status { margin-top: 25px; display: none; background: #252525; padding: 15px; border-radius: 8px; border-left: 5px solid #00aaff; }
        button { background: #00aaff; color: #fff; border: none; padding: 15px; border-radius: 8px; cursor: pointer; font-size: 1.1em; font-weight: bold; width: 100%; transition: 0.2s; }
        button:hover { background: #0088cc; }
        button:disabled { background: #444; cursor: not-allowed; }
        .info-text { font-size: 0.85em; color: #888; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="box">
        <h2>Entropia Log Toolkit</h2>
        
        <label>1. Select your 3GB chat.log</label>
        <input type="file" id="logInput" accept=".log,.txt" style="margin-bottom:20px;">

        <div class="setting-group">
            <label for="splitMode">2. How should we split it?</label>
            <select id="splitMode">
                <option value="year">By Year (Best for organization)</option>
                <option value="month">By Month (Best for 3GB+ files)</option>
                <option value="lines">By Line Count (Custom size)</option>
            </select>
            
            <div id="lineLimitContainer" style="display:none; margin-top:15px;">
                <label>Lines per file:</label>
                <input type="number" id="lineLimit" value="1000000">
                <p class="info-text">1 million lines is roughly 100-150MB.</p>
            </div>
        </div>

        <button id="processBtn">Process & Download</button>

        <div id="status">
            <div id="msg" style="font-weight:bold;">Ready to scan...</div>
            <div id="stats" style="font-size: 0.9em; margin-top: 10px; color: #bbb;"></div>
        </div>
    </div>

    <script>
        const splitMode = document.getElementById('splitMode');
        const lineLimitContainer = document.getElementById('lineLimitContainer');

        // Show/Hide the line count input
        splitMode.onchange = () => {
            lineLimitContainer.style.display = splitMode.value === 'lines' ? 'block' : 'none';
        };

        document.getElementById('processBtn').onclick = async () => {
            const fileInput = document.getElementById('logInput');
            if (!fileInput.files.length) return alert("Select a file first!");

            const file = fileInput.files[0];
            const btn = document.getElementById('processBtn');
            const msg = document.getElementById('msg');
            const stats = document.getElementById('stats');
            const mode = splitMode.value;
            const customLimit = parseInt(document.getElementById('lineLimit').value);
            
            btn.disabled = true;
            document.getElementById('status').style.display = 'block';

            const stream = file.stream();
            const reader = stream.getReader();
            const decoder = new TextDecoder();
            
            let partialLine = '';
            let currentKey = null; 
            let currentBuffer = [];
            let totalLines = 0;
            let fileCounter = 1;

            try {
                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    const text = decoder.decode(value, { stream: true });
                    const lines = (partialLine + text).split(/\r?\n/);
                    partialLine = lines.pop();

                    for (const line of lines) {
                        totalLines++;
                        let foundKey = null;

                        if (mode === 'year') {
                            const m = line.match(/^(\d{4})/);
                            if (m) foundKey = m[0];
                        } else if (mode === 'month') {
                            const m = line.match(/^(\d{4}-\d{2})/);
                            if (m) foundKey = m[0];
                        } else if (mode === 'lines') {
                            if (totalLines % customLimit === 0) foundKey = `part_${fileCounter++}`;
                        }

                        // If the key changed (new year/month/chunk), save the buffer
                        if (foundKey && currentKey !== null && foundKey !== currentKey) {
                            await saveFile(currentBuffer.join('\n'), `entropia_${currentKey}.txt`);
                            currentBuffer = [];
                        }
                        
                        if (foundKey) currentKey = foundKey;
                        currentBuffer.push(line);
                    }
                    msg.innerText = `Current Segment: ${currentKey || 'Scanning...'}`;
                    stats.innerText = `Processed ${totalLines.toLocaleString()} lines...`;
                }

                // Final save
                if (currentBuffer.length > 0) {
                    await saveFile(currentBuffer.join('\n'), `entropia_${currentKey || 'final'}.txt`);
                }

                msg.innerHTML = "<span style='color: #4CAF50;'>Done! All files ready.</span>";
                btn.disabled = false;

            } catch (e) {
                msg.innerText = "Error!";
                stats.innerText = e.message;
                btn.disabled = false;
            }
        };

        function saveFile(content, fileName) {
            return new Promise((resolve) => {
                const blob = new Blob([content], { type: 'text/plain' });
                const a = document.createElement('a');
                a.href = URL.createObjectURL(blob);
                a.download = fileName;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(a.href);
                    resolve();
                }, 250); // Pause to ensure browser downloads don't crash
            });
        }
    </script>
</body>
</html>
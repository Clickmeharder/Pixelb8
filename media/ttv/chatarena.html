<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chat Arena RPG</title>
<script src="https://unpkg.com/comfy.js/dist/comfy.min.js"></script>

<style>
body {
    margin:0;
    background:transparent;
    font-family:monospace;
    overflow:hidden;
}
canvas { display:block; margin:auto; }

/* Enemy HP list */
#enemyUI {
    position:absolute;
    top:10px;
    right:10px;
    color:#fff;
    font-size:13px;
    text-align:right;
    background:rgba(0,0,0,0.35);
    padding:6px 8px;
    border-radius:6px;
}

/* System messages */
#systemUI {
    position:absolute;
    top:10px;
    left:10px;
    width:320px;
    font-size:13px;
}
.sysMsg {
    background:rgba(0,0,0,0.5);
    color:#9ff;
    padding:4px 6px;
    margin-bottom:4px;
    border-radius:4px;
    animation: fadeout 6s forwards;
}

/* Tooltip hover */
#tooltip {
    position: absolute;
    pointer-events: none;
    background: rgba(0,0,0,0.7);
    color: #fff;
    padding: 6px 8px;
    border-radius: 6px;
    font-family: monospace;
    font-size: 13px;
    display: none;
    white-space: nowrap;
}

/* Player stats overlay */
#playerStatsWindow {
    position:absolute;
    top:50px;
    left:50%;
    transform:translateX(-50%);
    width:400px;
    max-height:400px;
    overflow:auto;
    background:rgba(0,0,0,0.85);
    color:#fff;
    font-family:monospace;
    font-size:13px;
    padding:10px;
    border-radius:8px;
    display:none;
    z-index:10;
}
#playerStatsWindow h3 {
    margin-top:0;
}
#playerStatsWindow button {
    margin-top:8px;
    padding:4px 6px;
    border:none;
    border-radius:4px;
    cursor:pointer;
}
areaDisplay{
    position:absolute;
    top:10px;
    left:50%;
    transform:translateX(-50%);
    color:#fff;
    font-size:16px;
    background:rgba(0,0,0,0.5);
    padding:4px 8px;
    border-radius:6px;
}

@keyframes fadeout {
    0% { opacity:1; }
    70% { opacity:1; }
    100% { opacity:0; }
}
</style>
</head>

<body>

<canvas id="c" width="900" height="500"></canvas>
<div id="enemyUI"></div>
<div id="systemUI"></div>
<div id="tooltip"></div>
<div id="areaDisplay"></div>

<!-- Player stats overlay -->
<div id="playerStatsWindow">
    <h3>Players</h3>
    <div id="playerStatsContent"></div>
    <button onclick="document.getElementById('playerStatsWindow').style.display='none'">Close</button>
</div>

<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");

/* ================= STATE ================= */
let area = 1;
const areaDisplay = document.getElementById("areaDisplay");
let enemies = [];
let boss = null;
let players = {};
let floaters = [];
let enemyUI = document.getElementById("enemyUI");
let systemUI = document.getElementById("systemUI");
const backgrounds = {
    home: "rgba(20,20,40,1)", // simple Home area color
    dungeon: "rgba(50,30,10,1)" // cave/dungeon color
};
let currentArea = "home"; // can be 'home', 'dungeon', etc.
/* ================= SYSTEM UI ================= */
function systemMessage(text){
    const div = document.createElement("div");
    div.className = "sysMsg";
    div.textContent = text;
    systemUI.appendChild(div);
    setTimeout(()=>div.remove(),6000);
}

/* ================= TOOLTIP HOVER ================= */
const tooltip = document.getElementById("tooltip");
let mouse = {x:0,y:0};

c.addEventListener("mousemove", e=>{
    const rect = c.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
    
    let hoverPlayer = null;
    for(let p of Object.values(players)){
        if(p.dead) continue;
        let dx = mouse.x - p.x;
        let dy = mouse.y - p.y;
        if(Math.sqrt(dx*dx + dy*dy) < 30){
            hoverPlayer = p;
            break;
        }
    }

    if(hoverPlayer){
        tooltip.style.left = (e.clientX + 15) + "px";
        tooltip.style.top = (e.clientY + 15) + "px";
        tooltip.style.display = "block";
        tooltip.innerHTML = `
            <b>${hoverPlayer.name}</b><br>
            HP: ${hoverPlayer.hp}/${hoverPlayer.maxHp}<br>
            Attack Lv: ${hoverPlayer.stats.attackLevel} (${hoverPlayer.stats.attackXP} XP)<br>
            Heal Lv: ${hoverPlayer.stats.healLevel} (${hoverPlayer.stats.healXP} XP)<br>
            Combat Lv: ${hoverPlayer.stats.combatLevel}
        `;
    } else {
        tooltip.style.display = "none";
    }
});

/* ================= FLOATING TEXT ================= */
function spawnFloater(text,x,y,color){
    floaters.push({text,x,y,color,life:60});
}

/* ================= PERSISTENCE ================= */
function loadStats(name){
    return JSON.parse(localStorage.getItem("stats_"+name)) || {
        attackLevel:1, attackXP:0,
        healLevel:1, healXP:0,
        combatLevel:1,
        loot:{ dmg:0, heal:0 }
    };
}
function saveStats(name){
    localStorage.setItem("stats_"+name, JSON.stringify(players[name].stats));
}
function xpNeeded(lvl){ return Math.floor(40*Math.pow(1.5,lvl)); }

/* ================= WAVES ================= */

let dungeonQueue = [];
let dungeonCountdown = null;

function joinDungeonQueue(p){
    if(!dungeonQueue.includes(p.name)) {
        dungeonQueue.push(p.name);
        systemMessage(`${p.name} joined the dungeon queue (${dungeonQueue.length} players)`);
    }
    
    if(!dungeonCountdown){
        dungeonCountdown = setTimeout(() => {
            startDungeon();
            dungeonCountdown = null;
        }, 60000); // 60 seconds
        systemMessage("Dungeon will start in 60 seconds!");
    }
}

function startDungeon(){
    currentArea = "dungeon";
    systemMessage("Dungeon starts now!");
    spawnWave();
    startDungeonEnemyAttack();
}

//================= levels ========================== */
function updateAreaDisplay() {
    areaDisplay.textContent = `Current Area: ${currentArea.toUpperCase()}`;
}
function spawnWave(){
    enemies=[]; boss=null;
    let count = Math.min(3+area,6);
    for(let i=0;i<count;i++){
        enemies.push({
            hp:20+area*5,
            max:20+area*5,
            x:520+i*45,
            y:360,
            dead:false
        });
    }
    systemMessage(`ðŸŒ Area ${area} â€“ enemies approach`);
}
function spawnBoss(){
    boss={
        hp:120+area*80,
        max:120+area*80,
        x:720,y:250,dead:false
    };
    systemMessage("ðŸ‘¹ BOSS APPEARS");
}

/* ================= PLAYERS ================= */
function getPlayer(name,color){
    if(players[name]) return players[name];
    let stats = loadStats(name);
    players[name]={
        name,
        color:color||"#fff",
        x:120+Object.keys(players).length*70,
        y:360,
        hp:100,maxHp:100,
        dead:false,
        stats
    };
    systemMessage(`${name} joined the fight`);
    return players[name];
}

/* ================= DRAW FUNCTIONS ================= */
function drawHPBar(x,y,w,h,pct,color){
    ctx.fillStyle="#000";
    ctx.fillRect(x-w/2-1,y-1,w+2,h+2);
    ctx.fillStyle=color;
    ctx.fillRect(x-w/2,y,w*pct,h);
}

function drawStickman(p){
    if(p.dead){
        ctx.fillStyle="darkred";
        ctx.beginPath();
        ctx.arc(p.x,p.y+30,18,0,Math.PI*2);
        ctx.fill();
        return;
    }

    // Check if hovered
    let hovered = false;
    if(mouse.x && mouse.y){
        let dx = mouse.x - p.x;
        let dy = mouse.y - p.y;
        if(Math.sqrt(dx*dx + dy*dy) < 30) hovered = true;
    }

    // Draw HP bar
    drawHPBar(p.x,p.y-60,44,6,p.hp/p.maxHp,"#44ff88");

    // Outline/glow if hovered
    if(hovered){
        ctx.lineWidth=8;
        ctx.strokeStyle="yellow";
        stickmanPath(p);
    }

    // Normal stickman
    ctx.lineWidth=6; ctx.strokeStyle="#000"; stickmanPath(p);
    ctx.lineWidth=3; ctx.strokeStyle=p.color; stickmanPath(p);

    // Name
    ctx.font="16px monospace"; ctx.textAlign="center"; ctx.textBaseline="top";
    ctx.fillStyle="#000"; ctx.fillText(p.name,p.x,p.y+60);
    ctx.fillStyle=p.color; ctx.fillText(p.name,p.x,p.y+58);
}
function stickmanPath(p){
    ctx.beginPath(); ctx.arc(p.x,p.y-35,11,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x,p.y-24); ctx.lineTo(p.x,p.y+18); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x-16,p.y-5); ctx.lineTo(p.x+16,p.y-5); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(p.x,p.y+18); ctx.lineTo(p.x-16,p.y+38);
    ctx.moveTo(p.x,p.y+18); ctx.lineTo(p.x+16,p.y+38); ctx.stroke();
}

function drawEnemies(){
    enemies.forEach(e=>{
        if(e.dead) return;
        drawHPBar(e.x,e.y-40,32,5,e.hp/e.max,"#ff5555");
        ctx.fillStyle="#aaa"; ctx.beginPath(); ctx.arc(e.x,e.y-20,14,0,Math.PI*2); ctx.fill();
    });
}
function drawBoss(){
    if(!boss||boss.dead) return;
    drawHPBar(boss.x,boss.y-80,90,8,boss.hp/boss.max,"#ff3333");
    ctx.fillStyle="#f33"; ctx.beginPath(); ctx.arc(boss.x,boss.y,60,0,Math.PI*2); ctx.fill();
}
function drawFloaters(){
    floaters.forEach(f=>{
        ctx.globalAlpha=f.life/60;
        ctx.fillStyle=f.color;
        ctx.font="14px monospace";
        ctx.fillText(f.text,f.x,f.y);
        f.y-=0.6; f.life--;
    });
    ctx.globalAlpha=1;
    floaters = floaters.filter(f=>f.life>0);
}
function updateEnemyUI(){
    let t="";
    enemies.forEach((e,i)=>{ if(!e.dead) t+=`Minion ${i+1}: ${e.hp}/${e.max}<br>`; });
    if(boss&&!boss.dead) t+=`<b>Boss:</b> ${boss.hp}/${boss.max}`;
    enemyUI.innerHTML=t;
}
function loop(){
    // Draw background
    ctx.fillStyle = backgrounds[currentArea] || "#000";
    ctx.fillRect(0,0,c.width,c.height);

    // Draw game objects
    drawEnemies(); drawBoss();
    Object.values(players).forEach(drawStickman);
    drawFloaters(); updateEnemyUI();

    // Update area display
    updateAreaDisplay();

    requestAnimationFrame(loop);
}

loop();

/* ================= COMBAT ================= */
function levelCheck(p,type){
    let lvl = type==="attack"?p.stats.attackLevel:p.stats.healLevel;
    let xp = type==="attack"?p.stats.attackXP:p.stats.healXP;
    if(xp>=xpNeeded(lvl)){
        if(type==="attack") p.stats.attackLevel++;
        else p.stats.healLevel++;

        // Update combat level (25% per attack/heal)
        p.stats.combatLevel = Math.floor((p.stats.attackLevel + p.stats.healLevel) * 0.25);

        systemMessage(`${p.name} leveled ${type}!`);
    }
}

function attackTarget(p){
    if(p.dead) return;

    let dmg = 6 + p.stats.attackLevel*2;
    let target = null;

    if(currentArea === "home"){
        // Home PvP: target nearest alive player that isn't self
        let playersAlive = Object.values(players).filter(pl => !pl.dead && pl.name !== p.name);
        if(playersAlive.length) {
            target = playersAlive[Math.floor(Math.random() * playersAlive.length)];
        }
    } else {
        // Normal enemies/boss
        target = enemies.find(e=>!e.dead) || (boss && !boss.dead && boss);
    }

    if(!target) return;

    target.hp -= dmg;
    spawnFloater(`-${dmg}`, target.x, target.y-30, "#ff5555");

    let xpGain = 8;
    p.stats.attackXP += xpGain;
    spawnFloater(`+${xpGain} XP`, p.x, p.y-80, "#55ffff");

    if(target.hp <= 0){
        target.hp = 0;
        target.dead = true;
        spawnFloater(`DEAD!`, target.x, target.y-30, "#ff0000");
        systemMessage(`${target.name} has been defeated by ${p.name}!`);

        // Optional: prevent PvP death XP in Home, or add special XP
    }

    levelCheck(p,"attack"); 
    saveStats(p.name);
}


function healTarget(p,t){
    if(p.dead||t.dead) return;
    let h=10+p.stats.healLevel*3;
    t.hp=Math.min(t.maxHp,t.hp+h);

    spawnFloater(`+${h}`,t.x,t.y-40,"#44ff88");

    let xpGain=8; p.stats.healXP+=xpGain;
    spawnFloater(`+${xpGain} XP`,p.x,p.y-80,"#55ffff");
    systemMessage(`${p.name} healed ${t.name} for ${h} HP and gained ${xpGain} XP`);

    levelCheck(p,"heal"); saveStats(p.name);
}
/* ================= SELF RESPAWN ================= */
function scheduleRespawn(p){
    if(!p.dead) return;
    systemMessage(`${p.name} will respawn in 60 seconds...`);
    setTimeout(() => {
        p.dead = false;
        p.hp = p.maxHp;
        systemMessage(`${p.name} has respawned!`);
    }, 60000);
}

/* ================= ENEMY ATTACK ================= */
let dungeonEnemyAttackInterval = null;

function startDungeonEnemyAttack() {
    if(dungeonEnemyAttackInterval) return; // already running

    dungeonEnemyAttackInterval = setInterval(()=>{
        if(currentArea !== "dungeon") return; // safety check

        let alive = Object.values(players).filter(p => !p.dead);
        if(!alive.length) return;

        let target = alive[Math.floor(Math.random() * alive.length)];
        let dmg = 6 + area*2;
        target.hp -= dmg;
        spawnFloater(`-${dmg}`, target.x, target.y-40, "#ff3333");

        if(target.hp <= 0){
            target.hp = 0;
            target.dead = true;
            systemMessage(`${target.name} has fallen`);
        }
    }, 3500);
}

function stopDungeonEnemyAttack() {
    if(dungeonEnemyAttackInterval) {
        clearInterval(dungeonEnemyAttackInterval);
        dungeonEnemyAttackInterval = null;
    }
}



/* ================= PLAYER STATS WINDOW ================= */
function showPlayerStats(){
    const container = document.getElementById("playerStatsContent");
    container.innerHTML = "";
    Object.values(players).forEach(p=>{
        container.innerHTML += `
            <b>${p.name}</b><br>
            HP: ${p.hp}/${p.maxHp}<br>
            Attack Lv: ${p.stats.attackLevel} (${p.stats.attackXP} XP)<br>
            Heal Lv: ${p.stats.healLevel} (${p.stats.healXP} XP)<br>
            Combat Lv: ${p.stats.combatLevel}<br>
            <hr>
        `;
    });
    document.getElementById("playerStatsWindow").style.display = "block";
}

/* ================= CHAT ================= */
ComfyJS.onChat = (user,msg,flags,extra)=>{
    let p=getPlayer(user,extra?.userColor);
    msg = msg.toLowerCase();

    if(msg === "attack") attackTarget(p);
    if(msg.startsWith("heal")){
        let name = msg.split(" ")[1];
        let t = players[name] || Object.values(players).filter(x=>!x.dead && x.name!==user)[0];
        if(t) healTarget(p, t);
    }
	    // New chat command to clear all player stats
    if(msg === "clearstats") {
        for (let key in localStorage) {
            if (key.startsWith("stats_")) localStorage.removeItem(key);
        }
        systemMessage("All player stats cleared!");
	};
    if(msg === "t" || msg === "revive" || msg === "respawn") scheduleRespawn(p);
	if(msg === "dungeon") joinDungeonQueue(p);
    if(msg==="stats") showPlayerStats();

}
/* ================= INIT ================= */

ComfyJS.Init("jaedraze");
</script>
</body>

</html>

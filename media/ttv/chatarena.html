<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Chat Arena RPG</title>
<script src="https://unpkg.com/comfy.js/dist/comfy.min.js"></script>

<style>
body {
    margin:0;
    background:transparent;
    font-family:monospace;
    overflow:hidden;
}
canvas { display:block; margin:auto; }

/* Enemy HP list */
#enemyUI {
    position:absolute;
    top:10px;
    right:10px;
    color:#fff;
    font-size:13px;
    text-align:right;
    background:rgba(0,0,0,0.35);
    padding:6px 8px;
    border-radius:6px;
}

/* System messages */
#systemUI {
    position:absolute;
    top:10px;
    left:10px;
    width:320px;
    font-size:13px;
}
.sysMsg {
    background:rgba(0,0,0,0.5);
    color:#9ff;
    padding:4px 6px;
    margin-bottom:4px;
    border-radius:4px;
    animation: fadeout 6s forwards;
}
@keyframes fadeout {
    0% { opacity:1; }
    70% { opacity:1; }
    100% { opacity:0; }
}
</style>
</head>

<body>

<canvas id="c" width="900" height="500"></canvas>
<div id="enemyUI"></div>
<div id="systemUI"></div>

<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");

/* ================= STATE ================= */

let area = 1;
let enemies = [];
let boss = null;
let players = {};
let floaters = [];
let enemyUI = document.getElementById("enemyUI");
let systemUI = document.getElementById("systemUI");

/* ================= SYSTEM UI ================= */

function systemMessage(text){
    const div = document.createElement("div");
    div.className = "sysMsg";
    div.textContent = text;
    systemUI.appendChild(div);
    setTimeout(()=>div.remove(),6000);
}

/* ================= FLOATING TEXT ================= */

function spawnFloater(text,x,y,color){
    floaters.push({
        text,x,y,color,
        life:60
    });
}

/* ================= PERSISTENCE ================= */

function loadStats(name){
    return JSON.parse(localStorage.getItem("stats_"+name)) || {
        combatLevel:1, combatXP:0,
        healLevel:1, healXP:0,
        loot:{ dmg:0, heal:0 }
    };
}
function saveStats(name){
    localStorage.setItem("stats_"+name, JSON.stringify(players[name].stats));
}
function xpNeeded(lvl){ return Math.floor(40*Math.pow(1.5,lvl)); }

/* ================= WAVES ================= */

function spawnWave(){
    enemies=[]; boss=null;
    let count = Math.min(3+area,6);
    for(let i=0;i<count;i++){
        enemies.push({
            hp:20+area*5,
            max:20+area*5,
            x:520+i*45,
            y:360,
            dead:false
        });
    }
    systemMessage(`ðŸŒ Area ${area} â€“ enemies approach`);
}

function spawnBoss(){
    boss={
        hp:120+area*80,
        max:120+area*80,
        x:720,y:250,dead:false
    };
    systemMessage("ðŸ‘¹ BOSS APPEARS");
}

/* ================= PLAYERS ================= */

function getPlayer(name,color){
    if(players[name]) return players[name];
    let stats = loadStats(name);
    players[name]={
        name,
        color:color||"#fff",
        x:120+Object.keys(players).length*70,
        y:360,
        hp:100,maxHp:100,
        dead:false,
        stats
    };
    systemMessage(`${name} joined the fight`);
    return players[name];
}

/* ================= DRAW ================= */

function drawHPBar(x,y,w,h,pct,color){
    ctx.fillStyle="#000";
    ctx.fillRect(x-w/2-1,y-1,w+2,h+2);
    ctx.fillStyle=color;
    ctx.fillRect(x-w/2,y,w*pct,h);
}

function drawStickman(p){
    if(p.dead){
        ctx.fillStyle="darkred";
        ctx.beginPath();
        ctx.arc(p.x,p.y+30,18,0,Math.PI*2);
        ctx.fill();
        return;
    }

    drawHPBar(p.x,p.y-60,44,6,p.hp/p.maxHp,"#44ff88");

    ctx.lineWidth=6;
    ctx.strokeStyle="#000";
    stickmanPath(p);

    ctx.lineWidth=3;
    ctx.strokeStyle=p.color;
    stickmanPath(p);

    ctx.font="16px monospace";
    ctx.textAlign="center";
    ctx.textBaseline="top";

    ctx.fillStyle="#000";
    ctx.fillText(p.name,p.x,p.y+60);
    ctx.fillStyle=p.color;
    ctx.fillText(p.name,p.x,p.y+58);
}

function stickmanPath(p){
    ctx.beginPath(); ctx.arc(p.x,p.y-35,11,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x,p.y-24); ctx.lineTo(p.x,p.y+18); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x-16,p.y-5); ctx.lineTo(p.x+16,p.y-5); ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(p.x,p.y+18); ctx.lineTo(p.x-16,p.y+38);
    ctx.moveTo(p.x,p.y+18); ctx.lineTo(p.x+16,p.y+38);
    ctx.stroke();
}

function drawEnemies(){
    enemies.forEach(e=>{
        if(e.dead) return;
        drawHPBar(e.x,e.y-40,32,5,e.hp/e.max,"#ff5555");
        ctx.fillStyle="#aaa";
        ctx.beginPath();
        ctx.arc(e.x,e.y-20,14,0,Math.PI*2);
        ctx.fill();
    });
}

function drawBoss(){
    if(!boss||boss.dead) return;
    drawHPBar(boss.x,boss.y-80,90,8,boss.hp/boss.max,"#ff3333");
    ctx.fillStyle="#f33";
    ctx.beginPath();
    ctx.arc(boss.x,boss.y,60,0,Math.PI*2);
    ctx.fill();
}

function drawFloaters(){
    floaters.forEach(f=>{
        ctx.globalAlpha=f.life/60;
        ctx.fillStyle=f.color;
        ctx.font="14px monospace";
        ctx.fillText(f.text,f.x,f.y);
        f.y-=0.6;
        f.life--;
    });
    ctx.globalAlpha=1;
    floaters = floaters.filter(f=>f.life>0);
}

function updateEnemyUI(){
    let t="";
    enemies.forEach((e,i)=>{
        if(!e.dead) t+=`Minion ${i+1}: ${e.hp}/${e.max}<br>`;
    });
    if(boss&&!boss.dead) t+=`<b>Boss:</b> ${boss.hp}/${boss.max}`;
    enemyUI.innerHTML=t;
}

function loop(){
    ctx.clearRect(0,0,c.width,c.height);
    drawEnemies();
    drawBoss();
    Object.values(players).forEach(drawStickman);
    drawFloaters();
    updateEnemyUI();
    requestAnimationFrame(loop);
}
loop();

/* ================= COMBAT ================= */

function levelCheck(p,type){
    let lvl = type==="combat"?p.stats.combatLevel:p.stats.healLevel;
    let xp = type==="combat"?p.stats.combatXP:p.stats.healXP;
    if(xp>=xpNeeded(lvl)){
        if(type==="combat") p.stats.combatLevel++;
        else p.stats.healLevel++;
        systemMessage(`${p.name} leveled ${type}!`);
    }
}

function attackTarget(p){
    if(p.dead) return;
    let dmg = 6 + p.stats.combatLevel*2;
    let target = enemies.find(e=>!e.dead)||(boss&&!boss.dead&&boss);
    if(!target) return;

    target.hp-=dmg;

    // Spawn floating damage number
    spawnFloater(`-${dmg}`,target.x,target.y-30,"#ff5555");

    // Spawn XP floating text for attacker
    let xpGain = 8;
    p.stats.combatXP+=xpGain;
    spawnFloater(`+${xpGain} XP`,p.x,p.y-80,"#55ffff");

    // System message for XP gain
    systemMessage(`${p.name} dealt ${dmg} damage to ${target===boss?"BOSS":"Minion"} and gained ${xpGain} XP`);

    if(target.hp<=0){
        target.dead=true;
        spawnFloater(`DEAD!`,target.x,target.y-30,"#ff0000");
        systemMessage(`${target===boss?"Boss":"Minion"} was defeated!`);
        if(enemies.every(e=>e.dead)&&!boss) spawnBoss();
        if(target===boss){ area++; spawnWave(); }
    }

    levelCheck(p,"combat");
    saveStats(p.name);
}

function healTarget(p,t){
    if(p.dead||t.dead) return;
    let h=10+p.stats.healLevel*3;
    t.hp=Math.min(t.maxHp,t.hp+h);

    // Floating heal
    spawnFloater(`+${h}`,t.x,t.y-40,"#44ff88");

    // XP gain floating
    let xpGain = 8;
    p.stats.healXP+=xpGain;
    spawnFloater(`+${xpGain} XP`,p.x,p.y-80,"#55ffff");

    // System messages
    systemMessage(`${p.name} healed ${t.name} for ${h} HP and gained ${xpGain} XP`);

    levelCheck(p,"heal");
    saveStats(p.name);
}


/* ================= ENEMY ATTACK ================= */

setInterval(()=>{
    let alive=Object.values(players).filter(p=>!p.dead);
    if(!alive.length) return;
    let t=alive[Math.floor(Math.random()*alive.length)];
    let dmg=6+area*2;
    t.hp-=dmg;
    spawnFloater(`-${dmg}`,t.x,t.y-40,"#ff3333");
    if(t.hp<=0){
        t.hp=0; t.dead=true;
        systemMessage(`${t.name} has fallen`);
    }
},3500);

/* ================= CHAT ================= */

ComfyJS.onChat=(user,msg,flags,extra)=>{
    let p=getPlayer(user,extra?.userColor);
    msg=msg.toLowerCase();
    if(msg==="attack") attackTarget(p);
    if(msg.startsWith("heal")){
        let name=msg.split(" ")[1];
        let t=players[name]||
              Object.values(players).filter(x=>!x.dead&&x.name!==user)[0];
        if(t) healTarget(p,t);
    }
};

spawnWave();
ComfyJS.Init("jaedraze");
</script>
</body>
</html>

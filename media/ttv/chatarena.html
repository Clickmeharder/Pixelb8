<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="assets/images/logo/pixelbotfavicon.png">
    <title>StickmenFall | HUD v2.2.0</title>
    <style>
        body { margin:0; background:transparent; font-family: 'Courier New', monospace; overflow:hidden; }
        canvas { display:block; margin:auto; background: #050505; border: 2px solid #333; }

        #enemyUI { position:absolute; top:10px; right:10px; color:#ff4444; font-size:14px; text-align:right; background:rgba(0,0,0,0.8); padding:10px; border-radius:4px; border: 1px solid #444; box-shadow: 0 0 10px rgba(255,0,0,0.2); }
        #systemUI { position:absolute; top:10px; left:10px; width:320px; font-size:13px; pointer-events:none; }

        .sysMsg { background:rgba(0,0,0,0.85); color:#0f0; padding:6px; margin-bottom:6px; border-radius:2px; border-left: 4px solid #0f0; animation: fadeout 8s forwards; text-shadow: 1px 1px 1px #000; }
        #tooltip { position: absolute; pointer-events: none; background: rgba(0,0,0,0.95); color: #fff; padding: 8px; border-radius: 4px; border: 1px solid #0ff; font-size: 13px; display: none; z-index: 100; box-shadow: 0 0 15px rgba(0,255,255,0.3); }
        #areaDisplay { position:absolute; bottom:15px; left:50%; transform:translateX(-50%); color:#0ff; font-size:16px; background:rgba(0,0,0,0.9); padding:6px 20px; border: 1px solid #0ff; text-transform: uppercase; letter-spacing: 2px; }

        @keyframes fadeout { 0% { opacity:1; } 85% { opacity:1; } 100% { opacity:0; } }
    </style>
</head>
<body>

<canvas id="c" width="1000" height="600"></canvas>
<div id="enemyUI"></div>
<div id="systemUI"></div>
<div id="tooltip"></div>
<div id="areaDisplay">StickmenFallv3.0.0- VIEWING: HOME</div>

<script src="https://cdn.jsdelivr.net/npm/comfy.js@latest/dist/comfy.js"></script>
<script>
/**
 * STICKMEN FALL - REFACTORED CORE
 * V2.2.0 - Performance Optimized
 */

const c = document.getElementById("c");
const ctx = c.getContext("2d");

/* ================= CONFIG & CONSTANTS ================= */
const TASK_DURATION = 15 * 60 * 1000;
const ITEM_DB = {
    "Rusty Dagger":     { type: "weapon",   power: 5,   speed: 2000, value: 40,   color: "#777" },
    "Iron Sword":       { type: "weapon",   power: 12,  speed: 2500, value: 200,  color: "#eee" },
    "shitty shortbow":  { type: "weapon",   power: 5,   speed: 1250, value: 30,   color: "#eee" },
    "decent shortbow":  { type: "weapon",   power: 8,   speed: 1000, value: 100,  color: "#eee" },
    "Fishing Rod":      { type: "tool",     power: 0,                value: 1,    color: "#8B4513" },
    "Leather Tunic":    { type: "armor",    def: 2,                  value: 60,   color: "#5c4033" },
    "Iron Plate":       { type: "armor",    def: 5,                  value: 300,  color: "#aaa" },
    "Paper Bag":        { type: "helmet",   def: 1,                  value: 5,    color: "#d2b48c" },
    "wig":              { type: "helmet",   def: 1,                  value: 5000, color: "yellow" },
    "Iron helmet":      { type: "helmet",   def: 3,                  value: 150,  color: "#aaa" },
    "leather Boots":    { type: "boots",    def: 1,                  value: 30,   color: "#5c4033" },
    "leather Booties":  { type: "boots",    def: 1,                  value: 35,   color: "#5c4033" },
    "Leather scrap":    { type: "material",                          value: 15,   color: "#a88d6d" },
    "Golden Bass":      { type: "fish",                              value: 100,  color: "#FFD700" }
};

const DANCE_UNLOCKS = {
    1: { name: "The Squat", minLvl: 1 },
    2: { name: "The Flail", minLvl: 5 },
    3: { name: "The Lean",  minLvl: 10 },
    4: { name: "The Op-Pa", minLvl: 2 }
};

/* ================= GAME STATE ================= */
let viewArea = "home"; 
let players = {};
let enemies = [];
let boss = null;
let floaters = [];
let arrows = [];
let dungeonQueue = [];
let dungeonActive = false;
let dungeonWave = 1;
let dungeonSecondsLeft = 0;
let dungeonCountdownInterval = null;
let buyerActive = false;
let forceBuyer = null;
let mouse = { x: 0, y: 0 };

/* ================= UTILITIES ================= */
const sysMsgUI = document.getElementById("systemUI");
const areaDisplay = document.getElementById("areaDisplay");

function systemMessage(text) {
    const div = document.createElement("div");
    div.className = "sysMsg";
    div.textContent = text;
    sysMsgUI.appendChild(div);
    setTimeout(() => div.remove(), 8000);
}

function spawnFloater(text, x, y, color) {
    floaters.push({ text, x, y, color, life: 100 });
}

function spawnArrow(startX, startY, endX, endY) {
    arrows.push({ x: startX, y: startY, tx: endX, ty: endY, life: 30 });
}

const getXPNeeded = (lvl) => Math.floor(50 * Math.pow(1.3, lvl));

function updateCombatLevel(p) {
    p.stats.combatLevel = Math.floor((p.stats.attackLevel + p.stats.healLevel + (p.stats.fishLevel * 0.5)) / 2);
}

/* ================= DATA PERSISTENCE ================= */
function loadStats(name) {
    const saved = localStorage.getItem("rpg_" + name);
    let s = saved ? JSON.parse(saved) : {
        attackLevel: 1, attackXP: 0, healLevel: 1, healXP: 0,
        fishLevel: 1, fishXP: 0, danceLevel: 1, danceXP: 0,
        combatLevel: 1, gold: 0, inventory: ["Fishing Rod"],
        equippedWeapon: null, equippedArmor: null, equippedHelmet: null,
        equippedBoots: null, wigColor: null
    };
    
    // Patching & Repairs
    if (isNaN(s.gold) || s.gold === null) s.gold = 0;
    if (!Array.isArray(s.inventory)) s.inventory = ["Fishing Rod"];
    if (!s.inventory.includes("Fishing Rod")) s.inventory.push("Fishing Rod");
    
    // Defaults for missing keys
    const defaults = { danceLevel:1, danceXP:0, gold:0, wigColor:null, equippedWeapon:null, equippedArmor:null, equippedHelmet:null, equippedBoots:null };
    Object.keys(defaults).forEach(key => { if (s[key] === undefined) s[key] = defaults[key]; });

    return s;
}

function saveStats(p) {
    localStorage.setItem("rpg_" + p.name, JSON.stringify(p.stats));
}

/* ================= PLAYER LOGIC ================= */
function getPlayer(name, color) {
    if (players[name]) return players[name];
    
    players[name] = {
        name, color: color || "#00ffff", x: Math.random() * 800 + 100, y: 450,
        targetX: null, hp: 100, maxHp: 100, dead: false, area: "home", 
        activeTask: null, danceStyle: 0, lastDanceXP: 0, lastAttackTime: 0,
        stats: loadStats(name), lean: 0
    };
    return players[name];
}

function movePlayer(p, targetArea) {
    if (p.dead) return systemMessage(`${p.name} is a corpse and cannot travel!`);
    p.area = targetArea;
    if (targetArea === "fishingpond") {
        p.x = Math.random() * 150 + 50; 
        p.y = 450 + Math.random() * 20;
    } else {
        p.x = Math.random() * 700 + 100;
        p.y = 400 + Math.random() * 100;
    }
    p.activeTask = null; 
    if (targetArea !== "dungeon") dungeonQueue = dungeonQueue.filter(n => n !== p.name);
    systemMessage(`${p.name} traveled to ${targetArea}`);
}

/* ================= COMBAT & TASKS ================= */
function handleLoot(p, target) {
    let roll = Math.random();
    let drop = null;
    if (target === boss) {
        drop = roll > 0.5 ? "Iron Plate" : "Iron Sword";
    } else {
        if (roll > 0.98) drop = "Iron helmet";
        else if (roll > 0.90) drop = "shitty shortbow";
        else if (roll > 0.85) drop = "Leather Tunic";
        else if (roll > 0.70) drop = "Paper Bag";
    }
    if (drop) {
        p.stats.inventory.push(drop);
        systemMessage(`âœ¨ ${p.name} looted: ${drop}!`);
    }
}

function performAttack(p) {
    if (p.dead) return;
    let target = null;
    if (p.area === "dungeon") {
        target = enemies.find(e => !e.dead) || boss;
    } else if (p.area === "home") {
        target = Object.values(players).find(pl => pl.area === "home" && !pl.dead && pl.name !== p.name);
    }
    if (!target || target.dead) return;

    const isBow = p.stats.equippedWeapon?.toLowerCase().includes("shortbow");
    const rangeNeeded = isBow ? 200 : 50;
    p.targetX = target.x - (isBow ? 150 : 30);

    if (Math.abs(p.x - target.x) <= rangeNeeded) {
        let weapon = ITEM_DB[p.stats.equippedWeapon];
        let dmg = 5 + (p.stats.attackLevel * 2) + (weapon ? weapon.power : 0);
        if (isBow) spawnArrow(p.x + 10, p.y - 10, target.x, target.y);
        
        target.hp -= dmg;
        spawnFloater(`-${dmg}`, target.x, target.y - 40, "#ff4444");

        if (target.hp <= 0) {
            target.hp = 0; target.dead = true;
            systemMessage(`${target.name || "Enemy"} slain by ${p.name}!`);
            if (p.area === "dungeon") { handleLoot(p, target); checkDungeonProgress(); }
        }
        p.stats.attackXP += 10;
        if (p.stats.attackXP >= getXPNeeded(p.stats.attackLevel)) {
            p.stats.attackLevel++; p.stats.attackXP = 0;
            systemMessage(`${p.name} ATK UP (Lv ${p.stats.attackLevel})`);
        }
        updateCombatLevel(p); saveStats(p);
    }
}

function performFish(p) {
    if (p.area !== "fishingpond" || p.dead) return;
    if (p.stats.fishCaught === undefined) p.stats.fishCaught = 0;

    let roll = Math.random();
    let resultText = "";
    let isFish = false;
    let floaterColor = "#44ccff";

    if (buyerActive && Math.random() < 0.05) {
        p.stats.inventory.push("Golden Bass");
        resultText = "GOLDEN BASS!"; floaterColor = "#FFD700"; isFish = true;
        systemMessage(`âœ¨ ${p.name} landed a rare GOLDEN BASS!`);
    } else if (roll < 0.001) {
        p.stats.inventory.push("wig");
        resultText = "THE LEGENDARY WIG!"; floaterColor = "#FFD700";
        systemMessage(`[!] MYTHIC CATCH: ${p.name} found a Legendary Wig!`);
    } else if (roll < 0.015) {
        p.stats.inventory.push("leather Booties"); resultText = "leather Boots!";
    } else if (roll < 0.065) {
        p.stats.inventory.push("Leather scrap"); resultText = "Leather scrap"; floaterColor = "#a88d6d";
    } else {
        const weight = (Math.random() * 20 + 0.5).toFixed(1);
        const fishItem = `${weight}kg Bass`; 
        p.stats.inventory.push(fishItem);
        resultText = fishItem; isFish = true; p.stats.fishCaught++;
    }

    spawnFloater(`ðŸŽ£ ${resultText}`, p.x, p.y - 60, floaterColor);
    p.stats.fishXP += 10;
    if (p.stats.fishXP >= getXPNeeded(p.stats.fishLevel) * 2) {
        p.stats.fishLevel++; p.stats.fishXP = 0;
        systemMessage(`${p.name} FISH UP! (Lv ${p.stats.fishLevel})`);
    }
    updateCombatLevel(p); saveStats(p);
}

/* ================= NPC MERCHANT ================= */
function updateBuyerNPC() {
    const now = Date.now();
    let cycle = Math.floor(now / 60000) % 7; 
    let wasActive = buyerActive;
    buyerActive = (forceBuyer !== null) ? forceBuyer : (cycle === 0 || cycle === 1); 

    if (buyerActive && !wasActive) systemMessage("--- [NPC] THE FISH MERCHANT HAS ARRIVED (2X GOLD)! ---");
    else if (!buyerActive && wasActive) systemMessage("--- [NPC] THE FISH MERCHANT HAS LEFT THE AREA. ---");
}

/* ================= RENDERING ================= */
function drawScenery(ctx) {
    const now = Date.now();
    if (viewArea === "home") {
        ctx.fillStyle = "#252545"; ctx.fillRect(0, 475, c.width, 125);
        ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        for(let i=0; i<10; i++) ctx.fillRect((i * 100 + (now/50)) % c.width, 100 + (i*20), 2, 2);
	} else if (viewArea === "fishingpond") {
        // --- THE SHORE (Left side) ---
        ctx.fillStyle = "#1a2e1a"; // Dark Forest Green
        ctx.fillRect(0, 475, 250, 125); 

        // --- THE WATER (Right side) ---
        ctx.fillStyle = "#0a2e3a"; // Deep Water Blue
        ctx.fillRect(250, 485, c.width - 250, 115);

        // --- WATER RIPPLES ---
        ctx.strokeStyle = "rgba(0, 255, 255, 0.15)";
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
            let rx = 300 + (i * 150) + (Math.sin(now / 1000 + i) * 20);
            let ry = 520 + (i * 10);
            ctx.beginPath();
            ctx.ellipse(rx, ry, 40, 5, 0, 0, Math.PI * 2);
            ctx.stroke();
        }
        
        // Draw the Merchant if they are active
        drawBuyer(ctx);
    } else if (viewArea === "dungeon") {
        ctx.fillStyle = "#110505"; ctx.fillRect(0, 475, c.width, 125);
        ctx.strokeStyle = "#2a1010"; ctx.lineWidth = 4;
        ctx.beginPath(); ctx.moveTo(100, 0); ctx.lineTo(120, 100); ctx.lineTo(80, 200);
        ctx.moveTo(600, 0); ctx.lineTo(580, 150); ctx.lineTo(620, 300); ctx.stroke();
        ctx.fillStyle = "#1d0a0a";
        ctx.beginPath(); ctx.moveTo(200, 475); ctx.lineTo(225, 300); ctx.lineTo(250, 475); ctx.fill();
    }
}

function drawBuyer(ctx) {
    if (!buyerActive || viewArea !== "fishingpond") return;
    const bx = 115, by = 500, now = Date.now();
    let floatY = Math.sin(now / 800) * 6, sway = Math.sin(now / 400) * 3, gemPulse = 5 + Math.abs(Math.sin(now / 500)) * 10;
    ctx.save();
    ctx.translate(bx, by + floatY);
    ctx.fillStyle = "#2a1233"; ctx.beginPath(); ctx.moveTo(0, -30); ctx.quadraticCurveTo(-25 + sway, 0, -15 + sway, 35); ctx.lineTo(5, 30); ctx.fill();
    ctx.strokeStyle = "#111"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(-3, 10); ctx.lineTo(-5, 30); ctx.moveTo(3, 10); ctx.lineTo(5, 30); ctx.stroke();
    ctx.fillStyle = "#4B0082"; ctx.beginPath(); ctx.moveTo(0, -35); ctx.bezierCurveTo(-15, -20, -18, 10, -12, 25); ctx.lineTo(15, 25); ctx.bezierCurveTo(8, 10, 12, -20, 0, -35); ctx.fill();
    ctx.strokeStyle = "#FFD700"; ctx.lineWidth = 1.5; ctx.stroke();
    ctx.strokeStyle = "#ffdbac"; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(8, -15); ctx.lineTo(18, -5); ctx.stroke();
    ctx.strokeStyle = "#3e2723"; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(20, 30); ctx.lineTo(20, -50); ctx.stroke();
    ctx.shadowBlur = gemPulse; ctx.shadowColor = "#00ffff"; ctx.fillStyle = "#e0ffff"; ctx.beginPath(); ctx.arc(20, -55, 6, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
    ctx.fillStyle = "#0a0a0a"; ctx.beginPath(); ctx.ellipse(2, -45, 9, 11, 0, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = "#00ffff"; ctx.beginPath(); ctx.arc(6, -46, 1.5, 0, Math.PI * 2); ctx.arc(10, -46, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.fillStyle = "#4B0082"; ctx.beginPath(); ctx.moveTo(-8, -40); ctx.quadraticCurveTo(0, -65, 15, -40); ctx.quadraticCurveTo(18, -30, 10, -35); ctx.lineTo(-8, -35); ctx.fill();
    ctx.restore();
    ctx.textAlign = "center"; ctx.font = "bold 13px monospace";
    let textY = by + floatY - 75;
    ctx.fillStyle = "black"; ctx.fillText("MYSTERIOUS MERCHANT", bx + 1, textY + 1);
    ctx.fillStyle = "#ffff00"; ctx.fillText("MYSTERIOUS MERCHANT", bx, textY);
    ctx.font = "11px monospace"; ctx.fillStyle = "#00ffff"; ctx.fillText("âœ¦ 2X GOLD RATE âœ¦", bx, textY + 14);
}

function drawStickman(ctx, p) {
    if (p.area !== viewArea) return;
    const now = Date.now();
    let lean = p.lean || 0;

    if (p.dead) {
        ctx.fillStyle = "rgba(200, 0, 0, 0.6)"; ctx.beginPath(); ctx.ellipse(p.x, p.y + 20, 25, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.textAlign = "center"; ctx.fillStyle = "#555"; ctx.fillText("CORPSE", p.x, p.y + 10); return;
    }

    let bodyY = 0, armMove = 0;
    if (p.activeTask === "dancing") {
        if (p.danceStyle === 1) bodyY = Math.sin(now / 100) * 8;
        if (p.danceStyle === 2) armMove = Math.sin(now / 50) * 20;
        if (p.danceStyle === 3) lean = Math.sin(now / 200) * 0.6;
        if (p.danceStyle === 4) { bodyY = Math.abs(Math.sin(now / 150)) * -15; armMove = Math.sin(now / 150) * 5; }
    }

    ctx.strokeStyle = p.color; ctx.lineWidth = 3;
    const hX = p.x + (lean * 20), hY = p.y - 30 + bodyY;
    ctx.beginPath(); ctx.arc(hX, hY, 10, 0, Math.PI * 2); ctx.stroke();
    ctx.fillStyle = p.color; ctx.fillRect(hX + 2, hY - 3, 2, 2); ctx.fillRect(hX + 6, hY - 3, 2, 2);
    ctx.beginPath(); ctx.arc(hX + 4, hY + 2, 3, 0, Math.PI); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hX, hY + 10); ctx.lineTo(p.x, p.y + 10 + bodyY); ctx.stroke();

    if (p.activeTask !== "attacking") {
        ctx.beginPath();
        if (p.danceStyle === 4) {
            ctx.moveTo(hX, hY + 15); ctx.lineTo(hX - 10, hY + 25);
            ctx.moveTo(hX, hY + 15); ctx.lineTo(hX + 10, hY + 25);
        } else {
            ctx.moveTo(hX, hY + 15); ctx.lineTo(p.x - 18 + (lean * 10), p.y + 2 + bodyY + armMove);
            ctx.moveTo(hX, hY + 15);
            if (p.activeTask === "fishing") ctx.lineTo(p.x + 10 + (lean * 20), p.y - 10 + bodyY);
            else ctx.lineTo(p.x + 18 + (lean * 30), p.y + 2 + bodyY - armMove);
        }
        ctx.stroke();
    }

    let walk = (p.targetX !== null) ? Math.sin(now/100) * 10 : 0;
    let legSpread = (p.danceStyle === 4) ? 15 : 10;
    ctx.beginPath(); ctx.moveTo(p.x, p.y + 10 + bodyY); ctx.lineTo(p.x - legSpread - walk, p.y + 25);
    ctx.moveTo(p.x, p.y + 10 + bodyY); ctx.lineTo(p.x + legSpread + walk, p.y + 25); ctx.stroke();

    drawEquipment(ctx, p, now, bodyY, armMove, lean);
    ctx.fillStyle = "#444"; ctx.fillRect(p.x - 20, p.y - 55, 40, 4);
    ctx.fillStyle = "#0f0"; ctx.fillRect(p.x - 20, p.y - 55, 40 * (p.hp / p.maxHp), 4);
    ctx.fillStyle = "#fff"; ctx.font = "12px monospace"; ctx.textAlign = "center"; ctx.fillText(p.name, p.x, p.y + 40);
}

function drawEquipment(ctx, p, now, bodyY, armMove, lean) {
    const isAttacking = p.activeTask === "attacking";
    const isFishing = p.activeTask === "fishing" && p.area === "fishingpond";

    if (isFishing) {
        ctx.save(); ctx.strokeStyle = "#8B4513"; ctx.lineWidth = 2;
        let bob = Math.sin(now / 300) * 0.1;
        const rSX = p.x + 10 + (lean * 20), rSY = p.y - 10 + bodyY;
        const rTX = p.x + 50 + (lean * 20), rTY = p.y - 40 + (bob * 20) + bodyY;
        ctx.beginPath(); ctx.moveTo(rSX, rSY); ctx.lineTo(rTX, rTY); ctx.stroke();
        ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.moveTo(rTX, rTY);
        const wX = Math.max(rTX + 40, 280), wY = 510 + (Math.sin(now/500) * 5);
        ctx.quadraticCurveTo(rTX + 20, rTY + 40, wX, wY); ctx.stroke();
        ctx.fillStyle = "#ff4444"; ctx.beginPath(); ctx.arc(wX, wY, 3, 0, Math.PI * 2); ctx.fill(); ctx.restore();
    }

    if (p.stats.equippedWeapon && !isFishing) {
        const w = ITEM_DB[p.stats.equippedWeapon], isBow = p.stats.equippedWeapon.toLowerCase().includes("bow");
        ctx.save();
        if (isAttacking) {
            ctx.translate(p.x + (lean * 20) + 12, p.y - 10 + bodyY); ctx.rotate(Math.sin(now / 150) * 0.8);
            ctx.strokeStyle = p.stats.attackLevel > 10 ? "#0ff" : (w.color || "#ccc"); ctx.lineWidth = 3;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(25, -5); ctx.stroke();
            ctx.strokeStyle = "#aa8800"; ctx.beginPath(); ctx.moveTo(5, -8); ctx.lineTo(5, 8); ctx.stroke();
        } else {
            ctx.translate(p.x + (lean * 20) + (isBow ? -2 : -5), p.y - 5 + bodyY); ctx.rotate(isBow ? Math.PI/4 : Math.PI/1.2);
            ctx.strokeStyle = isBow ? "#8B4513" : w.color; ctx.lineWidth = 2;
            ctx.beginPath(); 
            if (isBow) ctx.arc(0, 0, 15, -Math.PI/2, Math.PI/2);
            else { ctx.moveTo(0,0); ctx.lineTo(20, 0); ctx.moveTo(5, -3); ctx.lineTo(5, 3); }
            ctx.stroke();
        }
        ctx.restore();
    }

    ["equippedArmor", "equippedHelmet", "equippedBoots"].forEach(slot => {
        const item = ITEM_DB[p.stats[slot]];
        if (!item) return;
        ctx.save();
        if (slot === "equippedArmor") {
            const hX = p.x + (lean * 20), hipX = p.x + (lean * 5);
            ctx.beginPath(); ctx.moveTo(hX - 7, p.y - 18 + bodyY); ctx.lineTo(hX + 7, p.y - 18 + bodyY);
            ctx.lineTo(hipX + 7, p.y + 8 + bodyY); ctx.lineTo(hipX - 7, p.y + 8 + bodyY); ctx.closePath();
            ctx.fillStyle = item.color; ctx.globalAlpha = 0.8; ctx.fill(); ctx.globalAlpha = 1; ctx.strokeStyle = "#000"; ctx.stroke();
        }
        if (slot === "equippedBoots") {
            let walk = (p.targetX !== null) ? Math.sin(now/100) * 10 : 0;
            ctx.fillStyle = item.color; ctx.strokeStyle = "#000";
            const fY = p.y + 25 + (bodyY * 0.3);
            ctx.fillRect(p.x - 10 - walk - 4, fY - 2, 8, 5); ctx.strokeRect(p.x - 10 - walk - 4, fY - 2, 8, 5);
            ctx.fillRect(p.x + 10 + walk - 4, fY - 2, 8, 5); ctx.strokeRect(p.x + 10 + walk - 4, fY - 2, 8, 5);
        }
        if (slot === "equippedHelmet") {
            const hX = p.x + (lean * 20), hY = p.y - 30 + bodyY;
            const name = p.stats.equippedHelmet.toLowerCase();
            if (name === "paper bag") { ctx.fillStyle = "#d2b48c"; ctx.fillRect(hX - 12, hY - 14, 24, 26); ctx.strokeRect(hX - 12, hY - 14, 24, 26); }
            else if (helmetName === "wig") {
				ctx.fillStyle = p.stats.wigColor || item.color || "#ffff00";
				ctx.strokeStyle = ctx.fillStyle;
				
				// 1. Back Hair (The "U" shape behind the head)
				// We draw from 0.2 PI to 0.8 PI (the bottom half) so it looks like it's behind the neck
				ctx.beginPath();
				ctx.arc(hX, hY, 13, 0.1 * Math.PI, 0.9 * Math.PI); 
				ctx.lineWidth = 6;
				ctx.stroke();

				// 2. Top Volume (The "Hat" of hair)
				// This draws from 1.0 PI to 2.0 PI (the top half circle only)
				ctx.beginPath();
				ctx.arc(hX, hY - 2, 11, Math.PI, 0); 
				ctx.fill();

				// 3. Side Locks (Draping down the sides)
				ctx.lineWidth = 5;
				ctx.beginPath();
				// Left side lock
				ctx.moveTo(hX - 10, hY - 2);
				ctx.quadraticCurveTo(hX - 14, hY + 10, hX - 11, hY + 18);
				// Right side lock
				ctx.moveTo(hX + 10, hY - 2);
				ctx.quadraticCurveTo(hX + 14, hY + 10, hX + 11, hY + 18);
				ctx.stroke();

				// 4. Little Bangs (Optional: Tiny bits on the forehead that don't cover eyes)
				ctx.lineWidth = 2;
				ctx.beginPath();
				ctx.moveTo(hX - 8, hY - 8); ctx.lineTo(hX - 4, hY - 10);
				ctx.moveTo(hX + 8, hY - 8); ctx.lineTo(hX + 4, hY - 10);
				ctx.stroke();
			}
        }
        ctx.restore();
    });
}

/* ================= DUNGEON SYSTEM ================= */
function spawnWave() {
    enemies = [];
    for (let i = 0; i < 3; i++) enemies.push({ name: "Minion", hp: 50 * dungeonWave, maxHp: 50 * dungeonWave, x: 600 + (i * 50), y: 400, dead: false });
    if (dungeonWave % 3 === 0) boss = { name: "DUNGEON OVERLORD", hp: 500, maxHp: 500, x: 800, y: 350, dead: false };
}

function checkDungeonProgress() {
    if (enemies.every(e => e.dead) && (!boss || boss.dead)) { dungeonWave++; spawnWave(); }
}

/* ================= CHAT COMMANDS ================= */
const cmdHandlers = {
    // --- Combat & Tasks ---
    attack: (p, args, user) => {
        if (p.activeTask === "attacking") return systemMessage(`${user}: Already attacking.`);
        p.activeTask = "attacking";
        p.taskEndTime = Date.now() + TASK_DURATION;
        p.lastAttackTime = 0;
        systemMessage(`${user} started attacking (15m idle)`);
    },

    fish: (p, args, user) => {
        if (p.area !== "fishingpond") return systemMessage(`${user}: Go to fishingpond first.`);
        if (p.activeTask === "fishing") return systemMessage(`${user}: Already fishing.`);
        p.targetX = 200;
        p.activeTask = "fishing";
        p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} started fishing!`);
    },

    heal: (p, args) => {
        let target = players[args[1]];
        if (target && target.area === p.area && !target.dead) {
            let amt = 10 + (p.stats.healLevel * 5);
            target.hp = Math.min(target.maxHp, target.hp + amt);
            spawnFloater(`+${amt} HP`, target.x, target.y - 40, "#0f0");
            p.stats.healXP += 15;
            if (p.stats.healXP >= xpNeeded(p.stats.healLevel)) {
                p.stats.healLevel++; p.stats.healXP = 0;
                systemMessage(`${p.name} HEAL UP! (Lv ${p.stats.healLevel})`);
            }
            saveStats(p);
        }
    },

    dance: (p, args, user) => {
        if (p.dead) return;
        const level = p.stats.danceLevel || 1;
        let chosenStyle = parseInt(args[1]);

        if (!isNaN(chosenStyle)) {
            if (!DANCE_UNLOCKS[chosenStyle]) return systemMessage(`${user}, try styles 1, 2, 3, or 4!`);
            if (level < DANCE_UNLOCKS[chosenStyle].minLvl) return systemMessage(`${user}, you need Dance Lvl ${DANCE_UNLOCKS[chosenStyle].minLvl} for that!`);
            p.danceStyle = chosenStyle;
        } else {
            let unlockedStyles = [1];
            if (level >= 5) unlockedStyles.push(2);
            if (level >= 10) unlockedStyles.push(3);
            if (level >= 20) unlockedStyles.push(4); // Keep the '20' logic for randoms
            p.danceStyle = unlockedStyles[Math.floor(Math.random() * unlockedStyles.length)];
        }

        p.activeTask = "dancing";
        p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} is performing ${DANCE_UNLOCKS[p.danceStyle].name}!`);
        saveStats(p);
    },

    listdances: (p) => {
        const lvl = p.stats.danceLevel;
        let msg = `Your Dance Lvl: ${lvl}. Unlocks: [1] The Squat (Lvl 1) `;
        msg += lvl >= 5 ? `[2] The Flail (Lvl 5) ` : `[2] LOCKED (Lvl 5) `;
        msg += lvl >= 10 ? `[3] The Lean (Lvl 10)` : `[3] LOCKED (Lvl 10)`;
        systemMessage(msg);
    },

    // --- Equipment & Inventory ---
    equip: (p, args) => {
        let inputName = args.slice(1).join(" ").toLowerCase();
        let invItem = p.stats.inventory.find(i => i.toLowerCase() === inputName);
        if (!invItem) return systemMessage(`${p.name}: You don't have "${args.slice(1).join(" ")}" in your inventory.`);

        let dbKey = Object.keys(ITEM_DB).find(k => k.toLowerCase() === invItem.toLowerCase());
        let itemData = ITEM_DB[dbKey];
        if (!itemData) return systemMessage(`System Error: ${invItem} has no stats in ITEM_DB.`);

        const msgs = { weapon: "equipped", armor: "put on", helmet: "is wearing", boots: "laced up" };
        const slotMap = { weapon: "equippedWeapon", armor: "equippedArmor", helmet: "equippedHelmet", boots: "equippedBoots" };

        if (slotMap[itemData.type]) {
            p.stats[slotMap[itemData.type]] = dbKey;
            systemMessage(`${p.name} ${msgs[itemData.type]} ${dbKey}!`);
            saveStats(p);
        }
    },

    unequip: (p, args) => {
        const target = args[1] ? args[1].toLowerCase() : "all";
        let changed = false;
        const slots = [
            { key: "equippedWeapon", match: ["weapon"] },
            { key: "equippedArmor", match: ["armor", "armour"] },
            { key: "equippedHelmet", match: ["helmet"] },
            { key: "equippedBoots", match: ["boots"] }
        ];

        slots.forEach(slot => {
            if (target === "all" || slot.match.includes(target)) {
                p.stats[slot.key] = null;
                changed = true;
            }
        });

        if (changed) {
            systemMessage(`${p.name} unequipped ${target === "all" ? "everything" : "their " + target}.`);
            saveStats(p);
        } else {
            systemMessage(`${p.name}: Invalid slot. Use !unequip (weapon/armor/helmet/boots/all)`);
        }
    },

    inventory: (p, args, user) => {
        let filter = args[1]?.toLowerCase() || "all";
        let items = p.stats.inventory;
        let result = items;

        if (filter === "weapons") result = items.filter(i => ITEM_DB[i]?.type === "weapon");
        else if (filter === "armor" || filter === "armour") result = items.filter(i => ["armor", "helmet", "boots"].includes(ITEM_DB[i]?.type));
        else if (filter === "boots") result = items.filter(i => ITEM_DB[i]?.type === "boots");
        else if (filter === "helmets") result = items.filter(i => ITEM_DB[i]?.type === "helmet");
        else if (filter === "fish") result = items.filter(i => i.includes("kg"));
        else if (filter === "tools") result = items.filter(i => ITEM_DB[i]?.type === "tool" || i === "Fishing Rod");

        if (result.length === 0) return systemMessage(`${user}'s ${filter} inventory is empty.`);

        let counts = {}, fishWeight = 0, fishCount = 0;
        result.forEach(item => {
            if (item.includes("kg")) {
                fishWeight += parseFloat(item.split("kg")[0]) || 0;
                fishCount++;
            } else counts[item] = (counts[item] || 0) + 1;
        });

        let output = `\n[ ${user.toUpperCase()}'S ${filter.toUpperCase()} ]`; // Old HUD Mimic
        if (fishCount > 0) output += `\n> Fish x${fishCount} (Total: ${fishWeight.toFixed(2)}kg)`;
        for (let [name, qty] of Object.entries(counts)) output += `\n> ${name} ${qty > 1 ? "x" + qty : ""}`;
        systemMessage(output);
    },

    // --- Economy ---
    sell: (p, args) => {
        if (p.stats.inventory.length === 0) return systemMessage(`${p.name}: Your inventory is empty.`);
        let target = args.slice(1).join(" ").toLowerCase();
        let totalGold = 0, itemsRemoved = 0;
        updateBuyerNPC();
        let multiplier = buyerActive ? 2 : 1;

        if (target === "fish") {
            p.stats.inventory = p.stats.inventory.filter(item => {
                if (item.toLowerCase().includes("kg")) {
                    let weight = parseFloat(item.split("kg")[0].replace(/[^0-9.]/g, ''));
                    if (!isNaN(weight)) {
                        totalGold += Math.floor(weight * 1 * multiplier);
                        itemsRemoved++; return false;
                    }
                }
                if (item === "Golden Bass") {
                    totalGold += ((ITEM_DB["Golden Bass"]?.value || 100) * multiplier);
                    itemsRemoved++; return false;
                }
                return true;
            });
        } else {
            let idx = p.stats.inventory.findIndex(i => i.toLowerCase() === target);
            if (idx !== -1) {
                let itemName = p.stats.inventory[idx];
                let price = ITEM_DB[itemName]?.value || 50;
                totalGold = (itemName === "Golden Bass") ? price * multiplier : price;
                p.stats.inventory.splice(idx, 1);
                itemsRemoved = 1;
            }
        }

        if (itemsRemoved > 0) {
            p.stats.gold = (p.stats.gold || 0) + (isNaN(totalGold) ? 0 : totalGold);
            let msg = `${p.name} sold ${itemsRemoved} item(s) for ${totalGold.toFixed(2)} gold!`;
            if (buyerActive) msg += " ðŸ’° [MERCHANT SPECIAL RATE]";
            systemMessage(msg);
            saveStats(p);
        } else systemMessage(`${p.name}: Could not find "${target}" to sell. Try "!sell fish".`);
    },

    bal: (p) => {
        systemMessage(`${p.name} has ${(p.stats.gold || 0).toFixed(2)} coins stuffed in their prison wallet`);
    },

    // --- Stats & Social ---
    stats: (p, args, user) => {
        let targetName = args[1]?.toLowerCase() || user.toLowerCase();
        let onlinePlayer = Object.values(players).find(pl => pl.name.toLowerCase() === targetName);
        let data = onlinePlayer ? onlinePlayer.stats : JSON.parse(localStorage.getItem("rpg_" + targetName));
        let finalName = onlinePlayer ? onlinePlayer.name : targetName;

        if (data) {
            systemMessage(`${finalName.toUpperCase()} - CB: ${data.combatLevel} | ATK: ${data.attackLevel} | FISH: ${data.fishLevel} | DANCE: ${data.danceLevel || 1} | HEAL: ${data.healLevel}`);
        } else systemMessage(`System: Could not find stats for ${targetName}`);
    },

    topstats: () => {
        let all = [];
        for (let i = 0; i < localStorage.length; i++) {
            let key = localStorage.key(i);
            if (key.startsWith("rpg_")) {
                try {
                    let d = JSON.parse(localStorage.getItem(key));
                    all.push({ name: key.replace("rpg_", ""), cb: d.combatLevel || 1 });
                } catch(e) {}
            }
        }
        all.sort((a, b) => b.cb - a.cb);
        systemMessage(`TOP PLAYERS: ` + all.slice(0, 5).map((s, i) => `#${i+1} ${s.name}(Lv${s.cb})`).join(" | "));
    },

    wigcolor: (p, args) => {
        if (!p.stats.equippedHelmet || p.stats.equippedHelmet.toLowerCase() !== "wig") return systemMessage(`${p.name}, you need to be wearing a wig to change its color!`);
        const colorArg = args[1];
        if (!colorArg) return systemMessage(`Usage: !wigcolor [color/hex]`);
        const isHex = /^#([0-9A-F]{3}){1,2}$/i.test(colorArg);
        if (isHex || SAFE_COLORS.includes(colorArg.toLowerCase())) {
            p.stats.wigColor = colorArg;
            saveStats(p);
            systemMessage(`${p.name}'s wig is now ${colorArg}!`);
        } else systemMessage(`Invalid color! Use a hex code like #ff00ff or names like 'pink'.`);
    },

    mingle: (p, args, user) => {
        if (p.area !== "home") return;
        let target = players[args[1]] || Object.values(players).find(pl => pl.name !== user && pl.area === "home" && !pl.dead);
        if (target) { p.mingleTarget = target; setTimeout(() => { p.mingleTarget = null; }, 5000); }
    }
};
const COMMANDS = {
    // --- Movement ---
    travel:  (p, args) => movePlayer(p, args[1]),
    home:    (p) => movePlayer(p, "home"),
    dungeon: (p) => movePlayer(p, "dungeon"),
    pond:    (p) => movePlayer(p, "fishingpond"),
    join:    cmdJoinDungeon,

    // --- Tasks ---
    dance:   cmdDance, 

    fish:    (p, args, user) => {
        if (p.area !== "fishingpond") return systemMessage(`${user}: Go to fishingpond first.`);
        p.targetX = 200; p.activeTask = "fishing"; p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} started fishing!`);
    },
    attack:  (p, args, user) => {
        p.activeTask = "attacking"; p.taskEndTime = Date.now() + TASK_DURATION;
        p.lastAttackTime = 0; systemMessage(`${user} started attacking!`);
    },
    heal:    cmdHeal,

    // --- Info & Economy ---
    stats:      (p, args, user) => cmdShowStats(user, args),
    topstats:   cmdTopStats,
	listdances: cmdListDances,
    inventory:  cmdInventory,
    sell:       cmdSell,
    bal:        (p) => systemMessage(`${p.name} has ${(p.stats.gold || 0).toFixed(2)} coins stuffed in their prison wallet`),
    wallet:     (p) => COMMANDS.bal(p),
    money:      (p) => COMMANDS.bal(p),

    // --- Equipment ---
    equip:      cmdEquip,
    unequip:    cmdUnequip,
    wigcolor:   cmdWigColor,

    // --- Social & Misc ---
    mingle:     cmdMingle,
    respawn:    (p) => {
        if (p.dead) { p.dead = false; p.hp = p.maxHp; systemMessage(`${p.name} returned to life!`); }
    }
};
const OLDCOMMANDS = {
    travel: (p, args) => movePlayer(p, args[1]),
    home: (p) => movePlayer(p, "home"),
    dungeon: (p) => movePlayer(p, "dungeon"),
    pond: (p) => movePlayer(p, "fishingpond"),
    join: (p) => {
        if (p.dead || dungeonQueue.includes(p.name)) return;
        dungeonQueue.push(p.name);
        systemMessage(`${p.name} joined queue (${dungeonQueue.length})`);
        if (!dungeonCountdownInterval) {
            dungeonSecondsLeft = 60;
            dungeonCountdownInterval = setInterval(() => {
                dungeonSecondsLeft--;
                if (dungeonSecondsLeft === 30) viewArea = "dungeon";
                if (dungeonSecondsLeft <= 0) { clearInterval(dungeonCountdownInterval); dungeonCountdownInterval = null; startDungeon(); }
            }, 1000);
        }
    },
    dance: (p, args, user) => {
        const lvl = p.stats.danceLevel || 1;
        let style = parseInt(args[1]);
        if (!isNaN(style)) {
            if (!DANCE_UNLOCKS[style] || lvl < DANCE_UNLOCKS[style].minLvl) return systemMessage(`${user}, you need Dance Lvl ${DANCE_UNLOCKS[style]?.minLvl} for that!`);
            p.danceStyle = style;
        } else {
            let unlocked = Object.keys(DANCE_UNLOCKS).filter(k => lvl >= DANCE_UNLOCKS[k].minLvl);
            p.danceStyle = parseInt(unlocked[Math.floor(Math.random() * unlocked.length)]);
        }
        p.activeTask = "dancing"; p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} is performing ${DANCE_UNLOCKS[p.danceStyle].name}!`);
    },
    listdances: (p) => {
        const lvl = p.stats.danceLevel;
        let msg = `Your Dance Lvl: ${lvl}. Unlocks: [1] The Squat (Lvl 1) `;
        msg += lvl >= 5 ? `[2] The Flail (Lvl 5) ` : `[2] LOCKED (Lvl 5) `;
        msg += lvl >= 10 ? `[3] The Lean (Lvl 10)` : `[3] LOCKED (Lvl 10)`;
        systemMessage(msg);
    },
    fish: (p, user) => {
        if (p.area !== "fishingpond") return systemMessage(`${user}: Go to fishingpond first.`);
        p.targetX = 200; p.activeTask = "fishing"; p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} started fishing!`);
    },
    attack: (p, user) => {
        p.activeTask = "attacking"; p.taskEndTime = Date.now() + TASK_DURATION;
        p.lastAttackTime = 0; systemMessage(`${user} started attacking!`);
    },
    heal: (p, args) => {
        let target = players[args[1]];
        if (target && target.area === p.area && !target.dead) {
            let amt = 10 + (p.stats.healLevel * 5);
            target.hp = Math.min(target.maxHp, target.hp + amt);
            spawnFloater(`+${amt} HP`, target.x, target.y - 40, "#0f0");
            p.stats.healXP += 15;
            if (p.stats.healXP >= getXPNeeded(p.stats.healLevel)) {
                p.stats.healLevel++; p.stats.healXP = 0; systemMessage(`${p.name} HEAL UP! (Lv ${p.stats.healLevel})`);
            }
            saveStats(p);
        }
    },
    wigcolor: (p, args) => {
        if (!p.stats.equippedHelmet || p.stats.equippedHelmet.toLowerCase() !== "wig") return systemMessage(`${p.name}, you need to wear a wig!`);
        const color = args[1];
        if (/^#([0-9A-F]{3}){1,2}$/i.test(color) || ["red","blue","green","pink","purple","orange","white","black","cyan","magenta","yellow"].includes(color?.toLowerCase())) {
            p.stats.wigColor = color; saveStats(p); systemMessage(`${p.name}'s wig is now ${color}!`);
        } else systemMessage(`Usage: !wigcolor [color/hex]`);
    },
    bal: (p) => systemMessage(`${p.name} has ${(p.stats.gold || 0).toFixed(2)} coins stuffed in their prison wallet`),
    wallet: (p) => COMMANDS.bal(p),
    money: (p) => COMMANDS.bal(p),
    stats: (p, args, user) => {
        let target = args[1] ? args[1].toLowerCase() : user.toLowerCase();
        let data = players[target] ? players[target].stats : JSON.parse(localStorage.getItem("rpg_" + target));
        if (data) systemMessage(`${target.toUpperCase()} - CB: ${data.combatLevel} | ATK: ${data.attackLevel} | FISH: ${data.fishLevel} | DANCE: ${data.danceLevel || 1} | HEAL: ${data.healLevel}`);
    },
    topstats: () => {
        let all = [];
        for (let i=0; i<localStorage.length; i++) {
            let key = localStorage.key(i);
            if (key.startsWith("rpg_")) {
                let d = JSON.parse(localStorage.getItem(key));
                all.push({ name: key.replace("rpg_", ""), cb: d.combatLevel || 1 });
            }
        }
        all.sort((a,b) => b.cb - a.cb);
        systemMessage(`TOP PLAYERS: ` + all.slice(0,5).map((s,i) => `#${i+1} ${s.name}(Lv${s.cb})`).join(" | "));
    },
    inventory: (p, args, user) => {
        let filter = args[1]?.toLowerCase() || "all";
        let counts = {}; let fishWeight = 0; let fishCount = 0;
        p.stats.inventory.forEach(item => {
            if (item.includes("kg")) { fishWeight += parseFloat(item) || 0; fishCount++; }
            else counts[item] = (counts[item] || 0) + 1;
        });
        let output = `\n[ ${user.toUpperCase()}'S ${filter.toUpperCase()} ]`;
        if (fishCount > 0) output += `\n> Fish x${fishCount} (${fishWeight.toFixed(2)}kg)`;
        for (let [name, qty] of Object.entries(counts)) output += `\n> ${name} ${qty > 1 ? "x" + qty : ""}`;
        systemMessage(output);
    },
    sell: (p, args) => {
        let target = args.slice(1).join(" ").toLowerCase();
        let gold = 0; let itemsRemoved = 0; let mult = buyerActive ? 2 : 1;
        if (target === "fish") {
            p.stats.inventory = p.stats.inventory.filter(item => {
                if (item.includes("kg")) { 
                    gold += Math.floor(parseFloat(item) * mult); itemsRemoved++; return false; 
                }
                if (item === "Golden Bass") { 
                    gold += (ITEM_DB["Golden Bass"].value * mult); itemsRemoved++; return false; 
                }
                return true;
            });
        } else {
            let idx = p.stats.inventory.findIndex(i => i.toLowerCase() === target);
            if (idx !== -1) { 
                let item = p.stats.inventory[idx];
                gold = (ITEM_DB[item]?.value || 50) * (item === "Golden Bass" ? mult : 1);
                p.stats.inventory.splice(idx, 1); itemsRemoved = 1;
            }
        }
        p.stats.gold += gold; saveStats(p);
        systemMessage(`${p.name} sold ${itemsRemoved} items for ${gold.toFixed(2)} gold! ${buyerActive ? "ðŸ’° [BONUS]" : ""}`);
    },
    equip: (p, args) => {
        let input = args.slice(1).join(" ").toLowerCase();
        let item = p.stats.inventory.find(i => i.toLowerCase() === input);
        if (!item) return systemMessage(`You don't have that.`);
        let data = ITEM_DB[item];
        if (data.type === "weapon") p.stats.equippedWeapon = item;
        else if (data.type === "armor") p.stats.equippedArmor = item;
        else if (data.type === "helmet") p.stats.equippedHelmet = item;
        else if (data.type === "boots") p.stats.equippedBoots = item;
        saveStats(p); systemMessage(`${p.name} equipped ${item}!`);
    },
    unequip: (p, args) => {
        const slot = args[1]?.toLowerCase() || "all";
        if (slot === "weapon" || slot === "all") p.stats.equippedWeapon = null;
        if (slot === "armor" || slot === "all") p.stats.equippedArmor = null;
        if (slot === "helmet" || slot === "all") p.stats.equippedHelmet = null;
        if (slot === "boots" || slot === "all") p.stats.equippedBoots = null;
        saveStats(p); systemMessage(`${p.name} unequipped ${slot}.`);
    },
    mingle: (p, args, user) => {
        if (p.area !== "home") return;
        let target = players[args[1]] || Object.values(players).find(pl => pl.name !== user && pl.area === "home" && !pl.dead);
        if (target) { p.mingleTarget = target; setTimeout(() => { p.mingleTarget = null; }, 5000); }
    },
    respawn: (p) => {
        if (p.dead) { p.dead = false; p.hp = p.maxHp; systemMessage(`${p.name} returned to life!`); }
    }
};
/* ================= ENGINE LOOP ================= */
function startDungeon() {
    dungeonActive = true; viewArea = "dungeon";
    dungeonQueue.forEach(name => {
        let p = players[name];
        if (p && !p.dead) { p.area = "dungeon"; p.y = -100; p.targetY = 450; }
    });
    spawnWave();
}

function tick() {
    const now = Date.now();
    updateBuyerNPC();
    
    // Physics & Task Timers
    Object.values(players).forEach(p => {
        if (p.activeTask && now > p.taskEndTime) { p.activeTask = null; p.targetX = null; }
        if (p.targetX !== null) {
            let dx = p.targetX - p.x;
            if (Math.abs(dx) > 5) { p.x += dx * 0.1; p.lean = dx > 0 ? 0.2 : -0.2; }
            else { p.lean = 0; if (p.activeTask !== "attacking") p.targetX = null; }
        }
        if (p.targetY !== undefined && p.y < p.targetY) { p.y += 10; if (p.y >= p.targetY) delete p.targetY; }
        
        // Interval Tasks
        if (!p.dead && p.activeTask === "dancing" && now - p.lastDanceXP > 5000) {
            p.stats.danceXP += (5 + p.danceStyle * 2); p.lastDanceXP = now;
            if (p.stats.danceXP >= p.stats.danceLevel * 100) { p.stats.danceLevel++; p.stats.danceXP = 0; saveStats(p); }
        }
        if (!p.dead && p.activeTask === "attacking") {
            let speed = ITEM_DB[p.stats.equippedWeapon]?.speed || 2500;
            if (now - p.lastAttackTime > speed) { performAttack(p); p.lastAttackTime = now; }
        }
    });

    // Arrow Physics
    for (let i = arrows.length - 1; i >= 0; i--) {
        let a = arrows[i]; a.x += (a.tx - a.x) * 0.2; a.y += (a.ty - a.y) * 0.2; a.life--;
        if (a.life <= 0 || Math.abs(a.tx - a.x) < 5) arrows.splice(i, 1);
    }
}

function render() {
    ctx.fillStyle = (viewArea === "home" ? "#1a1a2e" : (viewArea === "dungeon" ? "#160a0a" : "#0a1612"));
    ctx.fillRect(0, 0, c.width, c.height);
    drawScenery(ctx);
    
    Object.values(players).forEach(p => drawStickman(ctx, p));
    
    arrows.forEach(a => { ctx.strokeStyle = "#fff"; ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(a.x, a.y); ctx.lineTo(a.x + 10, a.y); ctx.stroke(); });
    
    if (viewArea === "dungeon") {
        enemies.forEach(e => { if(!e.dead){ ctx.fillStyle = "#f00"; ctx.fillRect(e.x, e.y, 20, 20); }});
        if (boss && !boss.dead) { ctx.fillStyle = "#ff00ff"; ctx.fillRect(boss.x, boss.y, 50, 50); }
    }

    for (let i = floaters.length - 1; i >= 0; i--) {
        let f = floaters[i]; ctx.fillStyle = f.color; ctx.globalAlpha = f.life / 100;
        ctx.fillText(f.text, f.x, f.y); f.y--; f.life--; if (f.life <= 0) floaters.splice(i, 1);
    }
    ctx.globalAlpha = 1;
    requestAnimationFrame(() => { tick(); render(); });
}

/* ================= EVENTS ================= */
ComfyJS.onChat = (user, msg, flags, extra) => {
    let p = getPlayer(user, extra.userColor);
    let args = msg.split(" ");
    let cmd = args[0].toLowerCase();

    // Map specific aliases to handlers
    if (cmdHandlers[cmd]) {
        cmdHandlers[cmd](p, args, user);
    } else if (cmd === "wallet" || cmd === "bal") {
        cmdHandlers.bal(p);
    } else {
        // Handle Movement & Queue (preserved logic)
        if (cmd === "travel")  movePlayer(p, args[1]);
        if (cmd === "home")    movePlayer(p, "home");
        if (cmd === "dungeon") movePlayer(p, "dungeon");
        if (cmd === "join")    joinDungeonQueue(p);
        if (cmd === "respawn" && p.dead) { 
            p.dead = false; p.hp = p.maxHp; 
            systemMessage(`${p.name} returned to life!`); 
        }
    }

    // Admin Controls
    if (flags.broadcaster || flags.mod) {
        const adminViews = { showhome: "home", showdungeon: "dungeon", showfishing: "fishingpond" };
        if (adminViews[cmd]) {
            viewArea = adminViews[cmd];
            document.getElementById("areaDisplay").textContent = `StickmenFallv2.1.9 - VIEWING: ${viewArea.toUpperCase()}`;
        }
        if (cmd === "spawnmerchant") { forceBuyer = true; updateBuyerNPC(); systemMessage("[ADMIN] Merchant forced to spawn."); }
        if (cmd === "despawnmerchant") { forceBuyer = false; updateBuyerNPC(); systemMessage("[ADMIN] Merchant forced to leave."); }
        if (cmd === "resetmerchant") { forceBuyer = null; updateBuyerNPC(); systemMessage("[ADMIN] Merchant returned to automatic schedule."); }
    }
};

// Start Engine
ComfyJS.Init("jaedraze");
tick();
render();

// Interval task for Fishing and Passive NPC Damage
setInterval(() => {
    Object.values(players).forEach(p => { if (p.activeTask === "fishing") performFish(p); });
    if (dungeonActive) {
        let dwellers = Object.values(players).filter(p => p.area === "dungeon" && !p.dead);
        if (dwellers.length > 0) enemies.forEach(e => {
            if (e.dead) return;
            let t = dwellers[Math.floor(Math.random() * dwellers.length)];
            t.hp -= 5; spawnFloater("-5", t.x, t.y-40, "#f00"); if (t.hp <= 0) t.dead = true;
        });
    }
}, 3000);

</script>
</body>
</html>
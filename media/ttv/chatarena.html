<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Twitch HUD RPG</title>
    <script src="https://unpkg.com/comfy.js/dist/comfy.min.js"></script>
    <style>
        body { margin:0; background:transparent; font-family:monospace; overflow:hidden; }
        canvas { display:block; margin:auto; background: #111; }

        #enemyUI { position:absolute; top:10px; right:10px; color:#ff4444; font-size:14px; text-align:right; background:rgba(0,0,0,0.6); padding:8px; border-radius:6px; border: 1px solid #444; }
        #systemUI { position:absolute; top:10px; left:10px; width:300px; font-size:13px; pointer-events:none; }
        .sysMsg { background:rgba(0,0,0,0.7); color:#0f0; padding:5px; margin-bottom:4px; border-radius:4px; border-left: 3px solid #0f0; animation: fadeout 8s forwards; }
        #tooltip { position: absolute; pointer-events: none; background: rgba(0,0,0,0.9); color: #fff; padding: 8px; border-radius: 4px; border: 1px solid #0ff; font-size: 13px; display: none; z-index: 100; }
        #areaDisplay { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); color:#0ff; font-size:18px; background:rgba(0,0,0,0.8); padding:5px 15px; border: 1px solid #0ff; text-transform: uppercase; }

        @keyframes fadeout { 0% { opacity:1; } 80% { opacity:1; } 100% { opacity:0; } }
    </style>
</head>
<body>

<canvas id="c" width="1000" height="600"></canvas>
<div id="enemyUI"></div>
<div id="systemUI"></div>
<div id="tooltip"></div>
<div id="areaDisplay">VIEWING: HOME</div>

<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");

/* ================= CONFIG & STATE ================= */
let viewArea = "home"; // What the streamer sees
let players = {};
let enemies = [];
let boss = null;
let floaters = [];
let dungeonQueue = [];
let dungeonTimer = null;
let dungeonActive = false;
let dungeonWave = 1;

const backgrounds = {
    home: "#1a1a2e",
    dungeon: "#160a0a",
    fishingpond: "#0a1612"
};

/* ================= UTILS ================= */
function systemMessage(text) {
    const div = document.createElement("div");
    div.className = "sysMsg";
    div.textContent = text;
    document.getElementById("systemUI").appendChild(div);
    setTimeout(() => div.remove(), 8000);
}

function spawnFloater(text, x, y, color) {
    floaters.push({ text, x, y, color, life: 100 });
}

function xpNeeded(lvl) { return Math.floor(50 * Math.pow(1.3, lvl)); }

function updateCombatLevel(p) {
    // Combat level = (Atk + Heal + (Fish / 2)) / 3
    // Fishing contributes half as much to combat level
    p.stats.combatLevel = Math.floor((p.stats.attackLevel + p.stats.healLevel + (p.stats.fishLevel * 0.5)) / 2);
}

/* ================= DATA PERSISTENCE ================= */
function loadStats(name) {
    const saved = localStorage.getItem("rpg_" + name);
    if (saved) return JSON.parse(saved);
    return {
        attackLevel: 1, attackXP: 0,
        healLevel: 1, healXP: 0,
        fishLevel: 1, fishXP: 0,
        combatLevel: 1,
        inventory: []
    };
}

function saveStats(p) {
    localStorage.setItem("rpg_" + p.name, JSON.stringify(p.stats));
}

/* ================= PLAYER LOGIC ================= */
function getPlayer(name, color) {
    if (players[name]) return players[name];
    players[name] = {
        name,
        color: color || "#00ffff",
        x: Math.random() * 800 + 100,
        y: 450,
        hp: 100,
        maxHp: 100,
        dead: false,
        area: "home",
        mingleTarget: null,
        stats: loadStats(name)
    };
    return players[name];
}

function movePlayer(p, targetArea) {
    if (p.dead) {
        systemMessage(`${p.name} is a corpse and cannot travel!`);
        return;
    }
    
    p.area = targetArea;
    p.x = Math.random() * 700 + 100;
    p.y = 400 + Math.random() * 100;
    
    // Remove from queue if they move elsewhere
    if (targetArea !== "dungeon") {
        dungeonQueue = dungeonQueue.filter(n => n !== p.name);
    }
    
    systemMessage(`${p.name} traveled to ${targetArea}`);
}

/* ================= SYSTEMS ================= */

// --- COMBAT ---
function performAttack(p) {
    if (p.dead) return;
    let dmg = 5 + (p.stats.attackLevel * 2);
    let target = null;

    if (p.area === "home") {
        // PvP at home
        let possible = Object.values(players).filter(pl => pl.area === "home" && !pl.dead && pl.name !== p.name);
        if (possible.length) target = possible[Math.floor(Math.random() * possible.length)];
    } else if (p.area === "dungeon") {
        // Attack enemies
        target = enemies.find(e => !e.dead) || boss;
    }

    if (!target || target.dead) return;

    target.hp -= dmg;
    spawnFloater(`-${dmg}`, target.x, target.y - 40, "#ff4444");
    
    p.stats.attackXP += 10;
    if (p.stats.attackXP >= xpNeeded(p.stats.attackLevel)) {
        p.stats.attackLevel++;
        p.stats.attackXP = 0;
        systemMessage(`${p.name} ATK UP! (Lv ${p.stats.attackLevel})`);
    }
    updateCombatLevel(p);
    saveStats(p);

    if (target.hp <= 0) {
        target.hp = 0;
        target.dead = true;
        systemMessage(`${target.name || "Enemy"} slain by ${p.name}!`);
        if (p.area === "dungeon") {
            p.stats.inventory.push("Bone Fragment");
            checkDungeonProgress();
        }
    }
}

// --- FISHING ---
function performFish(p) {
    if (p.area !== "fishingpond" || p.dead) return;
    
    const weights = [1.2, 5.5, 10.2, 0.5, 22.1];
    const weight = weights[Math.floor(Math.random() * weights.length)];
    const xpGain = 5;

    spawnFloater(`ðŸŽ£ ${weight}kg`, p.x, p.y - 60, "#44ccff");
    p.stats.fishXP += xpGain;
    
    if (p.stats.fishXP >= xpNeeded(p.stats.fishLevel) * 2) { // Fishing grows slower
        p.stats.fishLevel++;
        p.stats.fishXP = 0;
        systemMessage(`${p.name} FISH UP! (Lv ${p.stats.fishLevel})`);
    }
    p.stats.inventory.push(`Fish (${weight}kg)`);
    updateCombatLevel(p);
    saveStats(p);
}

// --- DUNGEON ---
function joinDungeonQueue(p) {
    if (p.dead) return;
    if (!dungeonQueue.includes(p.name)) {
        dungeonQueue.push(p.name);
        systemMessage(`${p.name} queued for Dungeon (${dungeonQueue.length} total)`);
    }
    if (!dungeonTimer) {
        systemMessage("Dungeon starting in 60s...");
        dungeonTimer = setTimeout(startDungeon, 60000);
    }
}

function startDungeon() {
    dungeonTimer = null;
    dungeonActive = true;
    dungeonQueue.forEach(name => {
        let p = players[name];
        if (p && !p.dead) p.area = "dungeon";
    });
    spawnWave();
}

function spawnWave() {
    enemies = [];
    for (let i = 0; i < 3; i++) {
        enemies.push({ name: "Minion", hp: 50 * dungeonWave, maxHp: 50 * dungeonWave, x: 600 + (i * 50), y: 400, dead: false });
    }
    if (dungeonWave % 3 === 0) {
        boss = { name: "DUNGEON OVERLORD", hp: 500, maxHp: 500, x: 800, y: 350, dead: false };
    }
}

function checkDungeonProgress() {
    let aliveEnemies = enemies.filter(e => !e.dead).length;
    if (aliveEnemies === 0 && (!boss || boss.dead)) {
        dungeonWave++;
        spawnWave();
    }
}

/* ================= DRAWING ================= */
function drawStickman(ctx, p) {
    const isVisible = (p.area === viewArea);
    if (!isVisible) return;

    if (p.dead) {
        // Blood splat
        ctx.fillStyle = "rgba(200, 0, 0, 0.6)";
        ctx.beginPath(); ctx.ellipse(p.x, p.y + 20, 25, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = "#555";
        ctx.font = "10px monospace";
        ctx.fillText("CORPSE", p.x, p.y + 10);
        return;
    }

    // Interaction Line (Mingle)
    if (p.mingleTarget) {
        ctx.strokeStyle = "rgba(255, 100, 255, 0.3)";
        ctx.setLineDash([5, 5]);
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.mingleTarget.x, p.mingleTarget.y); ctx.stroke();
        ctx.setLineDash([]);
    }

    ctx.strokeStyle = p.color;
    ctx.lineWidth = 3;
    // Head
    ctx.beginPath(); ctx.arc(p.x, p.y - 30, 10, 0, Math.PI * 2); ctx.stroke();
    // Body
    ctx.beginPath(); ctx.moveTo(p.x, p.y - 20); ctx.lineTo(p.x, p.y + 10); ctx.stroke();
    // Arms
    ctx.beginPath(); ctx.moveTo(p.x - 15, p.y - 10); ctx.lineTo(p.x + 15, p.y - 10); ctx.stroke();
    // Legs
    ctx.beginPath(); ctx.moveTo(p.x, p.y + 10); ctx.lineTo(p.x - 10, p.y + 25); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x, p.y + 10); ctx.lineTo(p.x + 10, p.y + 25); ctx.stroke();

    // HP Bar
    ctx.fillStyle = "#444"; ctx.fillRect(p.x - 20, p.y - 50, 40, 5);
    ctx.fillStyle = "#0f0"; ctx.fillRect(p.x - 20, p.y - 50, 40 * (p.hp / p.maxHp), 5);
    
    // Name
    ctx.fillStyle = "#fff"; ctx.font = "12px monospace"; ctx.textAlign = "center";
    ctx.fillText(`${p.name} (Lv${p.stats.combatLevel})`, p.x, p.y + 45);
}

function gameLoop() {
    ctx.fillStyle = backgrounds[viewArea];
    ctx.fillRect(0, 0, c.width, c.height);

    // Update Enemy UI
    let enemyText = "";
    if (viewArea === "dungeon") {
        enemies.forEach(e => { if(!e.dead) enemyText += `Enemy: ${e.hp}hp<br>`; });
        if (boss && !boss.dead) enemyText += `<b>BOSS: ${boss.hp}hp</b>`;
    }
    document.getElementById("enemyUI").innerHTML = enemyText;

    // Draw Entities
    Object.values(players).forEach(p => drawStickman(ctx, p));
    
    if (viewArea === "dungeon") {
        enemies.forEach(e => {
            if (!e.dead) {
                ctx.fillStyle = "#f00"; ctx.fillRect(e.x, e.y, 20, 20);
                ctx.fillStyle = "#fff"; ctx.fillText(e.hp, e.x + 10, e.y - 5);
            }
        });
        if (boss && !boss.dead) {
            ctx.fillStyle = "#ff00ff"; ctx.fillRect(boss.x, boss.y, 50, 50);
        }
    }

    // Draw Floaters
    floaters.forEach((f, i) => {
        ctx.fillStyle = f.color;
        ctx.globalAlpha = f.life / 100;
        ctx.fillText(f.text, f.x, f.y);
        f.y -= 1; f.life--;
        if (f.life <= 0) floaters.splice(i, 1);
    });
    ctx.globalAlpha = 1;

    requestAnimationFrame(gameLoop);
}

/* ================= CHAT COMMANDS ================= */
ComfyJS.onChat = (user, msg, flags, extra) => {
    let p = getPlayer(user, extra.userColor);
    let args = msg.split(" ");
    let cmd = args[0].toLowerCase();

    if (cmd === "!attack") performAttack(p);
    
    if (cmd === "!heal") {
        let targetName = args[1];
        let target = players[targetName];
        if (target && target.area === p.area && !target.dead) {
            let amt = 10 + (p.stats.healLevel * 5);
            target.hp = Math.min(target.maxHp, target.hp + amt);
            spawnFloater(`+${amt} HP`, target.x, target.y - 40, "#0f0");
            p.stats.healXP += 15;
            if (p.stats.healXP >= xpNeeded(p.stats.healLevel)) {
                p.stats.healLevel++; p.stats.healXP = 0;
                systemMessage(`${p.name} HEAL UP! (Lv ${p.stats.healLevel})`);
            }
            saveStats(p);
        }
    }

    if (cmd === "!travel") movePlayer(p, args[1]);
    if (cmd === "!home" || cmd === "!retreat") movePlayer(p, "home");
    if (cmd === "!dungeon") movePlayer(p, "dungeon");
    if (cmd === "!fish") performFish(p);
    if (cmd === "!join") joinDungeonQueue(p);

    if (cmd === "!inventory" || cmd === "!inv") {
        systemMessage(`${user}'s items: ${p.stats.inventory.slice(-5).join(", ")}...`);
    }

    if (cmd === "!mingle") {
        if (p.area !== "home") return;
        let targetName = args[1];
        let target = players[targetName] || Object.values(players).find(pl => pl.name !== user && pl.area === "home" && !pl.dead);
        if (target) {
            p.mingleTarget = target;
            systemMessage(`${user} is mingling with ${target.name}`);
            setTimeout(() => { p.mingleTarget = null; }, 5000);
        }
    }

    if (cmd === "!respawn" && p.dead) {
        p.dead = false; p.hp = p.maxHp;
        systemMessage(`${p.name} returned to life!`);
    }

    // Streamer Controls
    if (flags.broadcaster || flags.mod) {
        if (cmd === "!showhome") { viewArea = "home"; document.getElementById("areaDisplay").textContent = "VIEWING: HOME"; }
        if (cmd === "!showdungeon") { viewArea = "dungeon"; document.getElementById("areaDisplay").textContent = "VIEWING: DUNGEON"; }
        if (cmd === "!showfishing") { viewArea = "fishingpond"; document.getElementById("areaDisplay").textContent = "VIEWING: FISHING POND"; }
    }
};

// Start Dungeon Enemy Attack Interval
setInterval(() => {
    if (!dungeonActive) return;
    let dungeonDwellers = Object.values(players).filter(p => p.area === "dungeon" && !p.dead);
    if (dungeonDwellers.length === 0) return;

    enemies.forEach(e => {
        if (e.dead) return;
        let target = dungeonDwellers[Math.floor(Math.random() * dungeonDwellers.length)];
        target.hp -= 5;
        spawnFloater(`-5`, target.x, target.y - 40, "#f00");
        if (target.hp <= 0) { target.hp = 0; target.dead = true; }
    });
}, 4000);

ComfyJS.Init("jaedraze");
gameLoop();

</script>
</body>
</html>
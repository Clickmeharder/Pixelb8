<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="assets/images/logo/pixelbotfavicon.png">
    <title>StickmenFall | HUD v2.2.1</title>
    <style>
        body { margin:0; background:transparent; font-family: 'Courier New', monospace; overflow:hidden; }
        canvas { display:block; margin:auto; background: #050505; border: 2px solid #333; }

        #enemyUI { position:absolute; top:10px; right:10px; color:#ff4444; font-size:14px; text-align:right; background:rgba(0,0,0,0.8); padding:10px; border-radius:4px; border: 1px solid #444; box-shadow: 0 0 10px rgba(255,0,0,0.2); }
        #systemUI { position:absolute; top:10px; left:10px; width:320px; font-size:13px; pointer-events:none; }

        .sysMsg { background:rgba(0,0,0,0.85); color:#0f0; padding:6px; margin-bottom:6px; border-radius:2px; border-left: 4px solid #0f0; animation: fadeout 8s forwards; text-shadow: 1px 1px 1px #000; white-space: pre-wrap; }
        #tooltip { position: absolute; pointer-events: none; background: rgba(0,0,0,0.95); color: #fff; padding: 8px; border-radius: 4px; border: 1px solid #0ff; font-size: 13px; display: none; z-index: 100; box-shadow: 0 0 15px rgba(0,255,255,0.3); }
        #areaDisplay { position:absolute; bottom:15px; left:50%; transform:translateX(-50%); color:#0ff; font-size:16px; background:rgba(0,0,0,0.9); padding:6px 20px; border: 1px solid #0ff; text-transform: uppercase; letter-spacing: 2px; }

        @keyframes fadeout { 0% { opacity:1; } 85% { opacity:1; } 100% { opacity:0; } }
    </style>
</head>
<body>

<canvas id="c" width="1000" height="600"></canvas>
<div id="enemyUI"></div>
<div id="systemUI"></div>
<div id="tooltip"></div>
<div id="areaDisplay">StickmenFallv2.2.1 - VIEWING: HOME</div>

<script src="https://cdn.jsdelivr.net/npm/comfy.js@latest/dist/comfy.js"></script>
<script>
/**
 * STICKMEN FALL - REFACTORED CORE
 * V2.2.1 - Full Legacy Logic Restoration
 */

const c = document.getElementById("c");
const ctx = c.getContext("2d");

/* ================= CONFIG & CONSTANTS ================= */
const TASK_DURATION = 15 * 60 * 1000;
const ITEM_DB = {
    "Rusty Dagger":     { type: "weapon",   power: 5,   speed: 2000, value: 40,   color: "#777" },
    "Iron Sword":       { type: "weapon",   power: 12,  speed: 2500, value: 200,  color: "#eee" },
    "shitty shortbow":  { type: "weapon",   power: 5,   speed: 1250, value: 30,   color: "#eee" },
    "decent shortbow":  { type: "weapon",   power: 8,   speed: 1000, value: 100,  color: "#eee" },
    "Fishing Rod":      { type: "tool",     power: 0,                value: 1,    color: "#8B4513" },
    "Leather Tunic":    { type: "armor",    def: 2,                  value: 60,   color: "#5c4033" },
    "Iron Plate":       { type: "armor",    def: 5,                  value: 300,  color: "#aaa" },
    "Paper Bag":        { type: "helmet",   def: 1,                  value: 5,    color: "#d2b48c" },
    "wig":              { type: "helmet",   def: 1,                  value: 5000, color: "yellow" },
    "Iron helmet":      { type: "helmet",   def: 3,                  value: 150,  color: "#aaa" },
    "leather Boots":    { type: "boots",    def: 1,                  value: 30,   color: "#5c4033" },
    "leather Booties":  { type: "boots",    def: 1,                  value: 35,   color: "#5c4033" },
    "Leather scrap":    { type: "material",                          value: 15,   color: "#a88d6d" },
    "Golden Bass":      { type: "fish",                              value: 100,  color: "#FFD700" }
};

const DANCE_UNLOCKS = {
    1: { name: "The Squat", minLvl: 1 },
    2: { name: "The Flail", minLvl: 5 },
    3: { name: "The Lean",  minLvl: 10 },
    4: { name: "The Op-Pa", minLvl: 2 }
};

/* ================= GAME STATE ================= */
let viewArea = "home"; 
let players = {};
let enemies = [];
let boss = null;
let floaters = [];
let arrows = [];
let dungeonQueue = [];
let dungeonActive = false;
let dungeonWave = 1;
let dungeonSecondsLeft = 0;
let dungeonCountdownInterval = null;
let buyerActive = false;
let forceBuyer = null;

/* ================= UTILITIES ================= */
const sysMsgUI = document.getElementById("systemUI");
const areaDisplay = document.getElementById("areaDisplay");

function systemMessage(text) {
    const div = document.createElement("div");
    div.className = "sysMsg";
    div.textContent = text;
    sysMsgUI.appendChild(div);
    setTimeout(() => div.remove(), 8000);
}

function spawnFloater(text, x, y, color) {
    floaters.push({ text, x, y, color, life: 100 });
}

function spawnArrow(startX, startY, endX, endY) {
    arrows.push({ x: startX, y: startY, tx: endX, ty: endY, life: 30 });
}

const getXPNeeded = (lvl) => Math.floor(50 * Math.pow(1.3, lvl));

function updateCombatLevel(p) {
    p.stats.combatLevel = Math.floor((p.stats.attackLevel + p.stats.healLevel + (p.stats.fishLevel * 0.5)) / 2);
}

/* ================= DATA PERSISTENCE ================= */
function loadStats(name) {
    const saved = localStorage.getItem("rpg_" + name);
    let s = saved ? JSON.parse(saved) : {
        attackLevel: 1, attackXP: 0, healLevel: 1, healXP: 0,
        fishLevel: 1, fishXP: 0, danceLevel: 1, danceXP: 0,
        combatLevel: 1, gold: 0, inventory: ["Fishing Rod"],
        equippedWeapon: null, equippedArmor: null, equippedHelmet: null,
        equippedBoots: null, wigColor: null
    };
    
    // Safety Patch
    if (isNaN(s.gold) || s.gold === null) s.gold = 0;
    if (!Array.isArray(s.inventory)) s.inventory = ["Fishing Rod"];
    const defaults = { danceLevel:1, danceXP:0, gold:0, wigColor:null };
    Object.keys(defaults).forEach(key => { if (s[key] === undefined) s[key] = defaults[key]; });
    return s;
}

function saveStats(p) {
    localStorage.setItem("rpg_" + p.name, JSON.stringify(p.stats));
}

/* ================= PLAYER LOGIC ================= */
function getPlayer(name, color) {
    if (players[name]) return players[name];
    players[name] = {
        name, color: color || "#0ff", x: Math.random() * 800 + 100, y: 450,
        targetX: null, hp: 100, maxHp: 100, dead: false, area: "home", 
        activeTask: null, danceStyle: 0, lastDanceXP: 0, lastAttackTime: 0,
        stats: loadStats(name), lean: 0, mingleTarget: null
    };
    return players[name];
}

function movePlayer(p, targetArea) {
    if (p.dead) return systemMessage(`${p.name} is a corpse and cannot travel!`);
    p.area = targetArea;
    if (targetArea === "fishingpond") {
        p.x = Math.random() * 150 + 50; 
        p.y = 450 + Math.random() * 20;
    } else {
        p.x = Math.random() * 700 + 100;
        p.y = 400 + Math.random() * 100;
    }
    p.activeTask = null; 
    if (targetArea !== "dungeon") dungeonQueue = dungeonQueue.filter(n => n !== p.name);
    systemMessage(`${p.name} traveled to ${targetArea}`);
}

/* ================= COMBAT & TASKS ================= */
function handleLoot(p, target) {
    let roll = Math.random();
    let drop = null;
    if (target === boss) { drop = roll > 0.5 ? "Iron Plate" : "Iron Sword"; }
    else {
        if (roll > 0.98) drop = "Iron helmet";
        else if (roll > 0.90) drop = "shitty shortbow";
        else if (roll > 0.85) drop = "Leather Tunic";
        else if (roll > 0.70) drop = "Paper Bag";
    }
    if (drop) {
        p.stats.inventory.push(drop);
        systemMessage(`âœ¨ ${p.name} looted: ${drop}!`);
    }
}

function performAttack(p) {
    if (p.dead) return;
    let target = null;
    if (p.area === "dungeon") { target = enemies.find(e => !e.dead) || boss; }
    else if (p.area === "home") { target = Object.values(players).find(pl => pl.area === "home" && !pl.dead && pl.name !== p.name); }
    if (!target || target.dead) return;

    const isBow = p.stats.equippedWeapon?.toLowerCase().includes("shortbow");
    const rangeNeeded = isBow ? 250 : 60;
    p.targetX = target.x - (isBow ? 180 : 40);

    if (Math.abs(p.x - target.x) <= rangeNeeded) {
        let weapon = ITEM_DB[p.stats.equippedWeapon];
        let dmg = 5 + (p.stats.attackLevel * 2) + (weapon ? weapon.power : 0);
        if (isBow) spawnArrow(p.x + 10, p.y - 10, target.x, target.y);
        
        target.hp -= dmg;
        spawnFloater(`-${dmg}`, target.x, target.y - 40, "#ff4444");

        if (target.hp <= 0) {
            target.hp = 0; target.dead = true;
            systemMessage(`${target.name || "Enemy"} slain by ${p.name}!`);
            if (p.area === "dungeon") { handleLoot(p, target); checkDungeonProgress(); }
        }
        p.stats.attackXP += 10;
        if (p.stats.attackXP >= getXPNeeded(p.stats.attackLevel)) {
            p.stats.attackLevel++; p.stats.attackXP = 0;
            systemMessage(`${p.name} ATK UP (Lv ${p.stats.attackLevel})`);
        }
        updateCombatLevel(p); saveStats(p);
    }
}

function performFish(p) {
    if (p.area !== "fishingpond" || p.dead) return;
    let roll = Math.random();
    let resultText = "";
    let floaterColor = "#44ccff";

    if (buyerActive && Math.random() < 0.05) {
        p.stats.inventory.push("Golden Bass");
        resultText = "GOLDEN BASS!"; floaterColor = "#FFD700";
        systemMessage(`âœ¨ ${p.name} landed a rare GOLDEN BASS!`);
    } else if (roll < 0.001) {
        p.stats.inventory.push("wig");
        resultText = "THE LEGENDARY WIG!"; floaterColor = "#FFD700";
        systemMessage(`[!] MYTHIC CATCH: ${p.name} found a Legendary Wig!`);
    } else if (roll < 0.015) {
        p.stats.inventory.push("leather Booties"); resultText = "leather Boots!";
    } else if (roll < 0.065) {
        p.stats.inventory.push("Leather scrap"); resultText = "Leather scrap"; floaterColor = "#a88d6d";
    } else {
        const weight = (Math.random() * 20 + 0.5).toFixed(1);
        resultText = `${weight}kg Bass`; 
        p.stats.inventory.push(resultText);
        p.stats.fishCaught = (p.stats.fishCaught || 0) + 1;
    }

    spawnFloater(`ðŸŽ£ ${resultText}`, p.x, p.y - 60, floaterColor);
    p.stats.fishXP += 10;
    if (p.stats.fishXP >= getXPNeeded(p.stats.fishLevel) * 2) {
        p.stats.fishLevel++; p.stats.fishXP = 0;
        systemMessage(`${p.name} FISH UP! (Lv ${p.stats.fishLevel})`);
    }
    updateCombatLevel(p); saveStats(p);
}

/* ================= NPC MERCHANT ================= */
function updateBuyerNPC() {
    const now = Date.now();
    let cycle = Math.floor(now / 60000) % 7; 
    let wasActive = buyerActive;
    buyerActive = (forceBuyer !== null) ? forceBuyer : (cycle === 0 || cycle === 1); 

    if (buyerActive && !wasActive) systemMessage("--- [NPC] THE FISH MERCHANT HAS ARRIVED (2X GOLD)! ---");
    else if (!buyerActive && wasActive) systemMessage("--- [NPC] THE FISH MERCHANT HAS LEFT THE AREA. ---");
}

/* ================= RENDERING ================= */
function drawScenery(ctx) {
    const now = Date.now();
    if (viewArea === "home") {
        ctx.fillStyle = "#1a1a2e"; ctx.fillRect(0, 0, c.width, c.height);
        ctx.fillStyle = "#252545"; ctx.fillRect(0, 475, c.width, 125);
    } else if (viewArea === "fishingpond") {
        ctx.fillStyle = "#0a1612"; ctx.fillRect(0, 0, c.width, c.height);
        ctx.fillStyle = "#1a2e1a"; ctx.fillRect(0, 475, 250, 125);
        ctx.fillStyle = "#0a2e3a"; ctx.fillRect(250, 485, c.width - 250, 115);
        drawBuyer(ctx);
    } else if (viewArea === "dungeon") {
        ctx.fillStyle = "#160a0a"; ctx.fillRect(0, 0, c.width, c.height);
        ctx.fillStyle = "#110505"; ctx.fillRect(0, 475, c.width, 125);
    }
}

function drawBuyer(ctx) {
    if (!buyerActive || viewArea !== "fishingpond") return;
    const bx = 115, by = 500, now = Date.now();
    let floatY = Math.sin(now / 800) * 6, sway = Math.sin(now / 400) * 3, gemPulse = 5 + Math.abs(Math.sin(now / 500)) * 10;
    ctx.save();
    ctx.translate(bx, by + floatY);
    ctx.fillStyle = "#2a1233"; ctx.beginPath(); ctx.moveTo(0, -30); ctx.quadraticCurveTo(-25 + sway, 0, -15 + sway, 35); ctx.lineTo(5, 30); ctx.fill();
    ctx.fillStyle = "#4B0082"; ctx.beginPath(); ctx.moveTo(0, -35); ctx.bezierCurveTo(-15, -20, -18, 10, -12, 25); ctx.lineTo(15, 25); ctx.fill();
    ctx.strokeStyle = "#3e2723"; ctx.lineWidth = 4; ctx.beginPath(); ctx.moveTo(20, 30); ctx.lineTo(20, -50); ctx.stroke();
    ctx.shadowBlur = gemPulse; ctx.shadowColor = "#0ff"; ctx.fillStyle = "#e0ffff"; ctx.beginPath(); ctx.arc(20, -55, 6, 0, Math.PI * 2); ctx.fill(); ctx.shadowBlur = 0;
    ctx.fillStyle = "#00ffff"; ctx.beginPath(); ctx.arc(6, -46, 1.5, 0, Math.PI * 2); ctx.arc(10, -46, 1.5, 0, Math.PI * 2); ctx.fill();
    ctx.restore();
    ctx.textAlign = "center"; ctx.font = "bold 13px monospace";
    ctx.fillStyle = "#ffff00"; ctx.fillText("MYSTERIOUS MERCHANT", bx, by + floatY - 75);
    ctx.font = "11px monospace"; ctx.fillStyle = "#0f0"; ctx.fillText("âœ¦ 2X GOLD RATE âœ¦", bx, by + floatY - 61);
}

function drawStickman(ctx, p) {
    if (p.area !== viewArea) return;
    const now = Date.now();
    let lean = p.lean || 0;

    if (p.dead) {
        ctx.fillStyle = "rgba(200, 0, 0, 0.6)"; ctx.beginPath(); ctx.ellipse(p.x, p.y + 20, 25, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.textAlign = "center"; ctx.fillStyle = "#555"; ctx.fillText("CORPSE", p.x, p.y + 10); return;
    }

    let bodyY = 0, armMove = 0;
    if (p.activeTask === "dancing") {
        if (p.danceStyle === 1) bodyY = Math.sin(now / 100) * 8;
        if (p.danceStyle === 2) armMove = Math.sin(now / 50) * 20;
        if (p.danceStyle === 3) lean = Math.sin(now / 200) * 0.6;
        if (p.danceStyle === 4) { bodyY = Math.abs(Math.sin(now / 150)) * -15; armMove = Math.sin(now / 150) * 5; }
    }

    ctx.strokeStyle = p.color; ctx.lineWidth = 3;
    const hX = p.x + (lean * 20), hY = p.y - 30 + bodyY;
    ctx.beginPath(); ctx.arc(hX, hY, 10, 0, Math.PI * 2); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(hX, hY + 10); ctx.lineTo(p.x, p.y + 10 + bodyY); ctx.stroke();

    // Arms
    ctx.beginPath();
    if (p.danceStyle === 4) { ctx.moveTo(hX, hY + 15); ctx.lineTo(hX - 10, hY + 25); ctx.moveTo(hX, hY + 15); ctx.lineTo(hX + 10, hY + 25); }
    else { 
        ctx.moveTo(hX, hY + 15); ctx.lineTo(p.x - 18, p.y + 2 + bodyY + armMove); 
        ctx.moveTo(hX, hY + 15); ctx.lineTo(p.x + 18, p.y + 2 + bodyY - armMove); 
    }
    ctx.stroke();

    // Legs
    let walk = (p.targetX !== null) ? Math.sin(now/100) * 10 : 0;
    ctx.beginPath(); ctx.moveTo(p.x, p.y + 10 + bodyY); ctx.lineTo(p.x - 10 - walk, p.y + 25);
    ctx.moveTo(p.x, p.y + 10 + bodyY); ctx.lineTo(p.x + 10 + walk, p.y + 25); ctx.stroke();

    drawEquipment(ctx, p, now, bodyY, armMove, lean);
    
    // HUD
    ctx.fillStyle = "#444"; ctx.fillRect(p.x - 20, p.y - 55, 40, 4);
    ctx.fillStyle = "#0f0"; ctx.fillRect(p.x - 20, p.y - 55, 40 * (p.hp / p.maxHp), 4);
    ctx.fillStyle = "#fff"; ctx.font = "12px monospace"; ctx.textAlign = "center"; ctx.fillText(p.name, p.x, p.y + 40);
}

function drawEquipment(ctx, p, now, bodyY, armMove, lean) {
    if (p.activeTask === "fishing" && p.area === "fishingpond") {
        ctx.save(); ctx.strokeStyle = "#8B4513"; ctx.lineWidth = 2;
        let bob = Math.sin(now / 300) * 0.1;
        const rSX = p.x + 18, rSY = p.y + bodyY;
        const rTX = p.x + 50, rTY = p.y - 40 + (bob * 20) + bodyY;
        ctx.beginPath(); ctx.moveTo(rSX, rSY); ctx.lineTo(rTX, rTY); ctx.stroke();
        ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.beginPath(); ctx.moveTo(rTX, rTY);
        ctx.quadraticCurveTo(rTX + 20, rTY + 40, Math.max(rTX + 40, 280), 510); ctx.stroke(); ctx.restore();
    }

    if (p.stats.equippedWeapon && p.activeTask !== "fishing") {
        const w = ITEM_DB[p.stats.equippedWeapon];
        ctx.save(); ctx.translate(p.x + 12, p.y - 10 + bodyY); ctx.rotate(Math.sin(now/150)*0.5);
        ctx.strokeStyle = w.color || "#ccc"; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(25,-5); ctx.stroke(); ctx.restore();
    }

    if (p.stats.equippedHelmet) {
        const hX = p.x + (lean * 20), hY = p.y - 30 + bodyY;
        if (p.stats.equippedHelmet.toLowerCase() === "wig") {
            ctx.fillStyle = p.stats.wigColor || "yellow"; ctx.beginPath(); ctx.arc(hX, hY-2, 11, Math.PI, 0); ctx.fill();
        }
    }
}

/* ================= DUNGEON SYSTEM ================= */
function spawnWave() {
    enemies = [];
    for (let i = 0; i < 3; i++) enemies.push({ name: "Minion", hp: 50 * dungeonWave, maxHp: 50 * dungeonWave, x: 600 + (i * 50), y: 400, dead: false });
    if (dungeonWave % 3 === 0) boss = { name: "DUNGEON OVERLORD", hp: 500, maxHp: 500, x: 800, y: 350, dead: false };
}

function checkDungeonProgress() {
    if (enemies.every(e => e.dead) && (!boss || boss.dead)) { dungeonWave++; spawnWave(); }
}

/* ================= CHAT COMMANDS ================= */
const COMMANDS = {
    travel: (p, args) => movePlayer(p, args[1]),
    home: (p) => movePlayer(p, "home"),
    dungeon: (p) => movePlayer(p, "dungeon"),
    pond: (p) => movePlayer(p, "fishingpond"),
    join: (p) => {
        if (p.dead || dungeonQueue.includes(p.name)) return;
        dungeonQueue.push(p.name);
        systemMessage(`${p.name} joined queue (${dungeonQueue.length})`);
        if (!dungeonCountdownInterval) {
            dungeonSecondsLeft = 60;
            dungeonCountdownInterval = setInterval(() => {
                dungeonSecondsLeft--;
                if (dungeonSecondsLeft === 30) viewArea = "dungeon";
                if (dungeonSecondsLeft <= 0) { clearInterval(dungeonCountdownInterval); dungeonCountdownInterval = null; startDungeon(); }
            }, 1000);
        }
    },
    dance: (p, args, user) => {
        const lvl = p.stats.danceLevel || 1;
        let style = parseInt(args[1]);
        if (!isNaN(style)) {
            if (!DANCE_UNLOCKS[style] || lvl < DANCE_UNLOCKS[style].minLvl) return systemMessage(`${user}, you need Dance Lvl ${DANCE_UNLOCKS[style]?.minLvl} for that!`);
            p.danceStyle = style;
        } else {
            let unlocked = Object.keys(DANCE_UNLOCKS).filter(k => lvl >= DANCE_UNLOCKS[k].minLvl);
            p.danceStyle = parseInt(unlocked[Math.floor(Math.random() * unlocked.length)]);
        }
        p.activeTask = "dancing"; p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} is performing ${DANCE_UNLOCKS[p.danceStyle].name}!`);
    },
    listdances: (p) => {
        const lvl = p.stats.danceLevel;
        let msg = `Your Dance Lvl: ${lvl}. Unlocks: [1] The Squat (Lvl 1) `;
        msg += lvl >= 5 ? `[2] The Flail (Lvl 5) ` : `[2] LOCKED (Lvl 5) `;
        msg += lvl >= 10 ? `[3] The Lean (Lvl 10)` : `[3] LOCKED (Lvl 10)`;
        systemMessage(msg);
    },
    fish: (p, user) => {
        if (p.area !== "fishingpond") return systemMessage(`${user}: Go to fishingpond first.`);
        p.targetX = 200; p.activeTask = "fishing"; p.taskEndTime = Date.now() + TASK_DURATION;
        systemMessage(`${user} started fishing!`);
    },
    attack: (p, user) => {
        p.activeTask = "attacking"; p.taskEndTime = Date.now() + TASK_DURATION;
        p.lastAttackTime = 0; systemMessage(`${user} started attacking!`);
    },
    heal: (p, args) => {
        let target = players[args[1]];
        if (target && target.area === p.area && !target.dead) {
            let amt = 10 + (p.stats.healLevel * 5);
            target.hp = Math.min(target.maxHp, target.hp + amt);
            spawnFloater(`+${amt} HP`, target.x, target.y - 40, "#0f0");
            p.stats.healXP += 15;
            if (p.stats.healXP >= getXPNeeded(p.stats.healLevel)) {
                p.stats.healLevel++; p.stats.healXP = 0; systemMessage(`${p.name} HEAL UP! (Lv ${p.stats.healLevel})`);
            }
            saveStats(p);
        }
    },
    wigcolor: (p, args) => {
        if (!p.stats.equippedHelmet || p.stats.equippedHelmet.toLowerCase() !== "wig") return systemMessage(`${p.name}, you need to wear a wig!`);
        const color = args[1];
        if (/^#([0-9A-F]{3}){1,2}$/i.test(color) || ["red","blue","green","pink","purple","orange","white","black","cyan","magenta","yellow"].includes(color?.toLowerCase())) {
            p.stats.wigColor = color; saveStats(p); systemMessage(`${p.name}'s wig is now ${color}!`);
        } else systemMessage(`Usage: !wigcolor [color/hex]`);
    },
    bal: (p) => systemMessage(`${p.name} has ${(p.stats.gold || 0).toFixed(2)} coins stuffed in their prison wallet`),
    wallet: (p) => COMMANDS.bal(p),
    money: (p) => COMMANDS.bal(p),
    stats: (p, args, user) => {
        let target = args[1] ? args[1].toLowerCase() : user.toLowerCase();
        let data = players[target] ? players[target].stats : JSON.parse(localStorage.getItem("rpg_" + target));
        if (data) systemMessage(`${target.toUpperCase()} - CB: ${data.combatLevel} | ATK: ${data.attackLevel} | FISH: ${data.fishLevel} | DANCE: ${data.danceLevel || 1} | HEAL: ${data.healLevel}`);
    },
    topstats: () => {
        let all = [];
        for (let i=0; i<localStorage.length; i++) {
            let key = localStorage.key(i);
            if (key.startsWith("rpg_")) {
                let d = JSON.parse(localStorage.getItem(key));
                all.push({ name: key.replace("rpg_", ""), cb: d.combatLevel || 1 });
            }
        }
        all.sort((a,b) => b.cb - a.cb);
        systemMessage(`TOP PLAYERS: ` + all.slice(0,5).map((s,i) => `#${i+1} ${s.name}(Lv${s.cb})`).join(" | "));
    },
    inventory: (p, args, user) => {
        let filter = args[1]?.toLowerCase() || "all";
        let counts = {}; let fishWeight = 0; let fishCount = 0;
        p.stats.inventory.forEach(item => {
            if (item.includes("kg")) { fishWeight += parseFloat(item) || 0; fishCount++; }
            else counts[item] = (counts[item] || 0) + 1;
        });
        let output = `\n[ ${user.toUpperCase()}'S ${filter.toUpperCase()} ]`;
        if (fishCount > 0) output += `\n> Fish x${fishCount} (${fishWeight.toFixed(2)}kg)`;
        for (let [name, qty] of Object.entries(counts)) output += `\n> ${name} ${qty > 1 ? "x" + qty : ""}`;
        systemMessage(output);
    },
    sell: (p, args) => {
        let target = args.slice(1).join(" ").toLowerCase();
        let gold = 0; let itemsRemoved = 0; let mult = buyerActive ? 2 : 1;
        if (target === "fish") {
            p.stats.inventory = p.stats.inventory.filter(item => {
                if (item.includes("kg")) { 
                    gold += Math.floor(parseFloat(item) * mult); itemsRemoved++; return false; 
                }
                if (item === "Golden Bass") { 
                    gold += (ITEM_DB["Golden Bass"].value * mult); itemsRemoved++; return false; 
                }
                return true;
            });
        } else {
            let idx = p.stats.inventory.findIndex(i => i.toLowerCase() === target);
            if (idx !== -1) { 
                let item = p.stats.inventory[idx];
                gold = (ITEM_DB[item]?.value || 50) * (item === "Golden Bass" ? mult : 1);
                p.stats.inventory.splice(idx, 1); itemsRemoved = 1;
            }
        }
        p.stats.gold += gold; saveStats(p);
        systemMessage(`${p.name} sold ${itemsRemoved} items for ${gold.toFixed(2)} gold! ${buyerActive ? "ðŸ’° [BONUS]" : ""}`);
    },
    equip: (p, args) => {
        let input = args.slice(1).join(" ").toLowerCase();
        let item = p.stats.inventory.find(i => i.toLowerCase() === input);
        if (!item) return systemMessage(`You don't have that.`);
        let data = ITEM_DB[item];
        if (data.type === "weapon") p.stats.equippedWeapon = item;
        else if (data.type === "armor") p.stats.equippedArmor = item;
        else if (data.type === "helmet") p.stats.equippedHelmet = item;
        else if (data.type === "boots") p.stats.equippedBoots = item;
        saveStats(p); systemMessage(`${p.name} equipped ${item}!`);
    },
    unequip: (p, args) => {
        const slot = args[1]?.toLowerCase() || "all";
        if (slot === "weapon" || slot === "all") p.stats.equippedWeapon = null;
        if (slot === "armor" || slot === "all") p.stats.equippedArmor = null;
        if (slot === "helmet" || slot === "all") p.stats.equippedHelmet = null;
        if (slot === "boots" || slot === "all") p.stats.equippedBoots = null;
        saveStats(p); systemMessage(`${p.name} unequipped ${slot}.`);
    },
    mingle: (p, args, user) => {
        if (p.area !== "home") return;
        let target = players[args[1]] || Object.values(players).find(pl => pl.name !== user && pl.area === "home" && !pl.dead);
        if (target) { p.mingleTarget = target; setTimeout(() => { p.mingleTarget = null; }, 5000); }
    },
    respawn: (p) => {
        if (p.dead) { p.dead = false; p.hp = p.maxHp; systemMessage(`${p.name} returned to life!`); }
    }
};

/* ================= ENGINE LOOP ================= */
function startDungeon() {
    dungeonActive = true; viewArea = "dungeon";
    dungeonQueue.forEach(name => {
        let p = players[name];
        if (p && !p.dead) { p.area = "dungeon"; p.y = -100; p.targetY = 450; }
    });
    spawnWave();
}

function tick() {
    const now = Date.now();
    updateBuyerNPC();
    Object.values(players).forEach(p => {
        if (p.activeTask && now > p.taskEndTime) { p.activeTask = null; }
        if (p.targetX !== null) {
            let dx = p.targetX - p.x;
            if (Math.abs(dx) > 5) { p.x += dx * 0.1; p.lean = dx > 0 ? 0.2 : -0.2; }
            else { p.lean = 0; if (p.activeTask !== "attacking") p.targetX = null; }
        }
        if (p.targetY && p.y < p.targetY) { p.y += 10; if (p.y >= p.targetY) delete p.targetY; }
        if (!p.dead && p.activeTask === "dancing" && now - p.lastDanceXP > 5000) {
            p.stats.danceXP += (5 + p.danceStyle * 2); p.lastDanceXP = now;
            if (p.stats.danceXP >= p.stats.danceLevel * 100) { p.stats.danceLevel++; p.stats.danceXP = 0; saveStats(p); }
        }
        if (!p.dead && p.activeTask === "attacking" && now - p.lastAttackTime > (ITEM_DB[p.stats.equippedWeapon]?.speed || 2500)) {
            performAttack(p); p.lastAttackTime = now;
        }
    });
}

function render() {
    drawScenery(ctx);
    Object.values(players).forEach(p => drawStickman(ctx, p));
    if (viewArea === "dungeon") {
        enemies.forEach(e => { if(!e.dead){ ctx.fillStyle = "#f00"; ctx.fillRect(e.x, e.y, 20, 20); }});
        if (boss && !boss.dead) { ctx.fillStyle = "#f0f"; ctx.fillRect(boss.x, boss.y, 50, 50); }
    }
    for (let i = floaters.length - 1; i >= 0; i--) {
        let f = floaters[i]; ctx.fillStyle = f.color; ctx.globalAlpha = f.life / 100;
        ctx.fillText(f.text, f.x, f.y); f.y--; f.life--; if (f.life <= 0) floaters.splice(i, 1);
    }
    ctx.globalAlpha = 1;
    requestAnimationFrame(render);
}

/* ================= EVENTS ================= */
ComfyJS.onChat = (user, msg, flags, extra) => {
    let p = getPlayer(user, extra.userColor);
    let args = msg.split(" ");
    let cmd = args[0].toLowerCase();
    if (COMMANDS[cmd]) COMMANDS[cmd](p, args, user);
    
    if (flags.broadcaster || flags.mod) {
        if (cmd === "spawnmerchant") { forceBuyer = true; updateBuyerNPC(); }
        if (cmd === "despawnmerchant") { forceBuyer = false; updateBuyerNPC(); }
        if (cmd === "showhome") { viewArea = "home"; areaDisplay.textContent = "StickmenFall - HOME"; }
        if (cmd === "showfishing") { viewArea = "fishingpond"; areaDisplay.textContent = "StickmenFall - POND"; }
        if (cmd === "showdungeon") { viewArea = "dungeon"; areaDisplay.textContent = "StickmenFall - DUNGEON"; }
    }
};

ComfyJS.Init("jaedraze");
setInterval(tick, 1000/30);
render();

setInterval(() => {
    Object.values(players).forEach(p => { if (p.activeTask === "fishing") performFish(p); });
}, 3000);

</script>
</body>
</html>
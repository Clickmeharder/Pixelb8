<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Twitch HUD RPG</title>
    <!--<script src="https://unpkg.com/comfy.js/dist/comfy.min.js"></script>-->
    <style>
        body { margin:0; background:transparent; font-family:monospace; overflow:hidden; }
        canvas { display:block; margin:auto; background: #111; }

        #enemyUI { position:absolute; top:10px; right:10px; color:#ff4444; font-size:14px; text-align:right; background:rgba(0,0,0,0.6); padding:8px; border-radius:6px; border: 1px solid #444; }
        #systemUI { position:absolute; top:10px; left:10px; width:300px; font-size:13px; pointer-events:none; }

		.sysMsg { background:rgba(0,0,0,0.7); color:#0f0; padding:5px; margin-bottom:4px; border-radius:4px; border-left: 3px solid #0f0; animation: fadeout 8s forwards; }
        #tooltip { position: absolute; pointer-events: none; background: rgba(0,0,0,0.9); color: #fff; padding: 8px; border-radius: 4px; border: 1px solid #0ff; font-size: 13px; display: none; z-index: 100; }
        #areaDisplay { position:absolute; bottom:10px; left:50%; transform:translateX(-50%); color:#0ff; font-size:18px; background:rgba(0,0,0,0.8); padding:5px 15px; border: 1px solid #0ff; text-transform: uppercase; }

        @keyframes fadeout { 0% { opacity:1; } 80% { opacity:1; } 100% { opacity:0; } }
    </style>
</head>
<body>

<canvas id="c" width="1000" height="600"></canvas>
<div id="enemyUI"></div>
<div id="systemUI"></div>
<div id="tooltip"></div>
<div id="areaDisplay">StickenFallv2.1.3- VIEWING: HOME</div>

<script src="https://cdn.jsdelivr.net/npm/comfy.js@latest/dist/comfy.js"></script>
<script>
const c = document.getElementById("c");
const ctx = c.getContext("2d");

/* ====grr============= CONFIG & STATE ================= */
let viewArea = "home"; 
let players = {};
let enemies = [];
let boss = null;
let floaters = [];
let dungeonQueue = [];
let dungeonTimer = null;
let dungeonActive = false;
let dungeonWave = 1;
let dungeonSecondsLeft = 0;
let dungeonCountdownInterval = null; // To track the interval
let mouse = { x: 0, y: 0 };
const TASK_DURATION = 15 * 60 * 1000; // 15 Minutes

const backgrounds = {
    home: "#1a1a2e",
    dungeon: "#160a0a",
    fishingpond: "#0a1612"
};

/* ================= UTILS ================= */
function systemMessage(text) {
    const div = document.createElement("div");
    div.className = "sysMsg";
    div.textContent = text;
    document.getElementById("systemUI").appendChild(div);
    setTimeout(() => div.remove(), 8000);
}

function spawnFloater(text, x, y, color) {
    floaters.push({ text, x, y, color, life: 100 });
}

function xpNeeded(lvl) { return Math.floor(50 * Math.pow(1.3, lvl)); }

function updateCombatLevel(p) {
    p.stats.combatLevel = Math.floor((p.stats.attackLevel + p.stats.healLevel + (p.stats.fishLevel * 0.5)) / 2);
}

/* ================= DATA PERSISTENCE ================= */
/* ================= DATA PERSISTENCE ================= */
function loadStats(name) {
    const saved = localStorage.getItem("rpg_" + name);
    let stats = saved ? JSON.parse(saved) : {
        attackLevel: 1, attackXP: 0,
        healLevel: 1, healXP: 0,
        fishLevel: 1, fishXP: 0,
        combatLevel: 1,
        gold: 0,
        inventory: ["Fishing Rod"],
        equippedWeapon: null,
        equippedArmor: null,
        equippedHelmet: null,
		equippedBoots: null,
    };

    // --- SAFETY CHECKS FOR OLD SAVES ---
    
    // 1. Ensure Inventory exists as an array
    if (!stats.inventory || !Array.isArray(stats.inventory)) {
        stats.inventory = ["Fishing Rod"];
    }

    // 2. Ensure they actually have a Fishing Rod to progress
    if (!stats.inventory.includes("Fishing Rod")) {
        stats.inventory.push("Fishing Rod");
    }

    // 3. Patch missing currency and equipment slots
    if (stats.gold === undefined) stats.gold = 0;
    if (stats.equippedWeapon === undefined) stats.equippedWeapon = null;
    if (stats.equippedArmor === undefined) stats.equippedArmor = null;
    if (stats.equippedHelmet === undefined) stats.equippedHelmet = null;

    // Optional: Log legacy patches in HUD green color
    if (!saved) {
        console.log(`%c [HUD] New profile created for ${name}`, "color: #00ff00");
    }

    return stats;
}
function saveStats(p) {
    localStorage.setItem("rpg_" + p.name, JSON.stringify(p.stats));
}
const ITEM_DB = {
    // --- WEAPONS ---
	"Rusty Dagger":     { type: "weapon", power: 5,  speed: 400,  value: 40,   color: "#777" },
    "Iron Sword":       { type: "weapon", power: 12, speed: 700,  value: 200,  color: "#eee" },
    "shitty shortbow":  { type: "weapon", power: 5,  speed: 1200, value: 30,   color: "#eee" },
    "decent shortbow":  { type: "weapon", power: 8,  speed: 1000, value: 100,  color: "#eee" },
    // --- TOOLS ---
    "Fishing Rod":      { type: "tool",   power: 0,               value: 1,   color: "#8B4513" },
    
    // --- ARMOR ---
    "Leather Tunic":    { type: "armor",  def: 2,                 value: 60,   color: "#5c4033" },
    "Iron Plate":       { type: "armor",  def: 5,                 value: 300,  color: "#aaa" },
    
    // --- HELMETS ---
    "Paper Bag":        { type: "helmet", def: 1,                 value: 5,    color: "#d2b48c" },
    "wig":              { type: "helmet", def: 1,                 value: 5000, color: "yellow" }, // Legendary!
    "Iron helmet":      { type: "helmet", def: 3,                 value: 150,  color: "#aaa" },
    
    // --- BOOTS ---
    "leather Boots":    { type: "boots",  def: 1,                 value: 30,   color: "#5c4033" },
    "leather Booties":  { type: "boots",  def: 1,                 value: 35,   color: "#5c4033" },

    // --- MATERIALS ---
    "Leather scrap":    { type: "material",                       value: 15,   color: "#a88d6d" }
};

function getPlayer(name, color) {
    if (players[name]) return players[name];
    
    players[name] = {
        name, 
        color: color || "#00ffff",
        x: Math.random() * 800 + 100, 
        y: 450,
        targetX: null,
        hp: 100, 
        maxHp: 100, 
        dead: false,
        area: "home", 
        activeTask: null,
        danceStyle: 0, // <--- Correct way to add it!
        stats: loadStats(name)
    };
    
    return players[name];
}

function movePlayer(p, targetArea) {
    if (p.dead) {
        systemMessage(`${p.name} is a corpse and cannot travel!`);
        return;
    }
    p.area = targetArea;
    p.x = Math.random() * 700 + 100;
    p.y = 400 + Math.random() * 100;
    p.activeTask = null; // Clear tasks when moving manually
    if (targetArea !== "dungeon") dungeonQueue = dungeonQueue.filter(n => n !== p.name);
    systemMessage(`${p.name} traveled to ${targetArea}`);
}

/* ================= HOVER LOGIC ================= */
c.addEventListener('mousemove', (e) => {
    const rect = c.getBoundingClientRect();
    mouse.x = e.clientX - rect.left;
    mouse.y = e.clientY - rect.top;
});

function handleTooltips() {
    const tt = document.getElementById("tooltip");
    let hover = null;

    // Check Players in view
    Object.values(players).forEach(p => {
        if (p.area === viewArea && Math.hypot(p.x - mouse.x, p.y - mouse.y) < 30) hover = p;
    });

    // Check Enemies/Boss in view
    if (viewArea === "dungeon") {
        enemies.forEach(e => { if(!e.dead && Math.hypot(e.x - mouse.x, e.y - mouse.y) < 20) hover = e; });
        if (boss && !boss.dead && Math.hypot(boss.x - mouse.x, boss.y - mouse.y) < 40) hover = boss;
    }

    if (hover) {
        tt.style.display = "block";
        tt.style.left = (mouse.x + 15) + "px";
        tt.style.top = (mouse.y + 15) + "px";
        if (hover.name === "Minion" || hover.name === "DUNGEON OVERLORD") {
            tt.innerHTML = `<b style="color:#ff4444">${hover.name}</b><br>HP: ${hover.hp}/${hover.maxHp}`;
        } else {
            tt.innerHTML = `<b>${hover.name}</b> [Lv ${hover.stats.combatLevel}]<br>HP: ${hover.hp}/${hover.maxHp}<br>Task: ${hover.activeTask || 'Idle'}`;
        }
    } else { tt.style.display = "none"; }
}

/* ================= SYSTEMS TICKER (IDLE TASKS) ================= */
setInterval(() => {
    const now = Date.now();
    Object.values(players).forEach(p => {
        if (p.dead || !p.activeTask) return;
        if (now > p.taskEndTime) {
            systemMessage(`${p.name} stopped ${p.activeTask} (15m expired)`);
            p.activeTask = null; return;
        }

        if (p.activeTask === "fishing" && p.area === "fishingpond") {
            if (Math.random() > 0.8) performFish(p);
        }
        if (p.activeTask === "attacking") {
            if (Math.random() > 0.7) performAttack(p);
        }
    });
}, 3000);

// --- COMBAT ---
function performAttack(p) {
    if (p.dead) return;

    // 1. Identify Target
    let target = null;
    if (p.area === "dungeon") {
        target = enemies.find(e => !e.dead) || boss;
    } else if (p.area === "home") {
        target = Object.values(players).find(pl => pl.area === "home" && !pl.dead && pl.name !== p.name);
    }
    if (!target || target.dead) return;

    // 2. Determine Range and Position
    const isBow = p.stats.equippedWeapon?.toLowerCase().includes("shortbow");
    const rangeNeeded = isBow ? 200 : 50;
    
    // Set movement target: Bow users stay back, Melee users go close
    p.targetX = target.x - (isBow ? 150 : 30);

    // 3. Range Check & Combat Execution
    if (Math.abs(p.x - target.x) <= rangeNeeded) {
        let weapon = ITEM_DB[p.stats.equippedWeapon];
        let dmg = 5 + (p.stats.attackLevel * 2) + (weapon ? weapon.power : 0);
        
        // Visuals
        if (isBow) {
            spawnArrow(p.x + 10, p.y - 10, target.x, target.y);
        }
        
        target.hp -= dmg;
        spawnFloater(`-${dmg}`, target.x, target.y - 40, "#ff4444");

        // 4. Kill Logic & Looting
        if (target.hp <= 0) {
            target.hp = 0;
            target.dead = true;
            systemMessage(`${target.name || "Enemy"} slain by ${p.name}!`);

            if (p.area === "dungeon") {
                handleLoot(p, target); // Cleaned up loot into its own check
                checkDungeonProgress();
            }
        }

        // 5. XP and Progress
        p.stats.attackXP += 10;
        if (p.stats.attackXP >= xpNeeded(p.stats.attackLevel)) {
            p.stats.attackLevel++;
            p.stats.attackXP = 0;
            systemMessage(`${p.name} ATK UP (Lv ${p.stats.attackLevel})`);
        }
        updateCombatLevel(p);
        saveStats(p);
    }
}

// --- FISHING ---
function performFish(p) {
    if (p.area !== "fishingpond" || p.dead) return;
    
    let roll = Math.random();
    let resultText = "";
    
    // --- 1 IN 1000 RARITY LOGIC ---
    if (roll < 0.001) { // 0.1% chance (1 in 1000)
        p.stats.inventory.push("wig");
        resultText = "THE LEGENDARY WIG!";
        systemMessage(`[!] MYTHIC CATCH: ${p.name} found a Legendary Wig!`);
    } 
    else if (roll < 0.015) { // Next 1.4% (Approx 1.5% total for boots)
        p.stats.inventory.push("leather Booties");
        resultText = "leather Boots!";
    } 
    else if (roll < 0.065) { // Next 5% (0.015 + 0.05 = 0.065)
        p.stats.inventory.push("Leather scrap");
        resultText = "Leather scrap";
    } 
    else { // 93.5% chance for standard fish
        const weight = (Math.random() * 20 + 0.5).toFixed(1);
        const fishItem = `${weight}kg Bass`; 
        p.stats.inventory.push(fishItem);
        resultText = fishItem;
    }

    // Color coding based on the Old HUD style
    let floaterColor = "#44ccff"; // Default Blue
    if (resultText.includes("WIG")) floaterColor = "#FFD700"; // Gold
    if (resultText.includes("scrap")) floaterColor = "#a88d6d"; // Brownish

    spawnFloater(`ðŸŽ£ ${resultText}`, p.x, p.y - 60, floaterColor);
    
    // XP and Save logic
    p.stats.fishXP += 10;
    if (p.stats.fishXP >= xpNeeded(p.stats.fishLevel) * 2) {
        p.stats.fishLevel++; 
        p.stats.fishXP = 0;
        systemMessage(`${p.name} FISH UP! (Lv ${p.stats.fishLevel})`);
    }
    updateCombatLevel(p);
    saveStats(p);
}
// --- DUNGEON ---
function joinDungeonQueue(p) {
    if (p.dead) return;
    
    if (!dungeonQueue.includes(p.name)) {
        dungeonQueue.push(p.name);
        systemMessage(`${p.name} joined the queue (${dungeonQueue.length} total)`);
    }

    // If the timer isn't already running, start it
    if (!dungeonCountdownInterval) {
        dungeonSecondsLeft = 60;
        
        systemMessage("Dungeon timer started!");

        dungeonCountdownInterval = setInterval(() => {
            dungeonSecondsLeft--;

            // --- AUTO-SWITCH VIEW (30 seconds before start) ---
            if (dungeonSecondsLeft === 30) {
                viewArea = "dungeon";
                document.getElementById("areaDisplay").textContent = "StickenFallv2.1.3 - VIEWING: DUNGEON (PREPARING)";
                systemMessage("System: Switching view to Dungeon for upcoming raid...");
            }

            // --- START DUNGEON (At 0 seconds) ---
            if (dungeonSecondsLeft <= 0) {
                clearInterval(dungeonCountdownInterval);
                dungeonCountdownInterval = null;
                startDungeon();
            }
        }, 1000);
    }
}
function startDungeon() {
    dungeonSecondsLeft = 0; // Clear the counter
    dungeonActive = true;
    
    // Ensure the view is definitely on the dungeon
    viewArea = "dungeon"; 
    document.getElementById("areaDisplay").textContent = "StickenFallv2.1.3 - VIEWING: DUNGEON (ACTIVE)";

    dungeonQueue.forEach(name => {
        let p = players[name];
        if (p && !p.dead) {
            p.area = "dungeon";
            p.x = Math.random() * 400 + 50;
            p.y = -100; // Start higher up
            p.targetY = 450; 
        }
    });
    
    systemMessage("The Dungeon Gates have opened!");
    spawnWave();
}
function updatePhysics(p) {
    // Vertical Fall (Dungeon Entrance)
    if (p.targetY !== undefined && p.y < p.targetY) {
        p.y += 10; 
        if (p.y >= p.targetY) { p.y = p.targetY; delete p.targetY; }
    }

    // Horizontal Walk (Attacking/Moving)
    if (p.targetX !== null && p.targetX !== undefined) {
        let dx = p.targetX - p.x;
        if (Math.abs(dx) > 5) {
            p.x += dx * 0.1; // Smooth slide toward target
            // Cheeky "Leaning" effect while running
            p.lean = dx > 0 ? 0.2 : -0.2;
        } else {
            p.lean = 0;
            // If they were running to attack but target is gone, return to idle
            if (p.activeTask !== "attacking") p.targetX = null;
        }
    }
}
function spawnWave() {
    enemies = [];
    for (let i = 0; i < 3; i++) {
        enemies.push({ name: "Minion", hp: 50 * dungeonWave, maxHp: 50 * dungeonWave, x: 600 + (i * 50), y: 400, dead: false });
    }
    if (dungeonWave % 3 === 0) {
        boss = { name: "DUNGEON OVERLORD", hp: 500, maxHp: 500, x: 800, y: 350, dead: false };
    }
}

function checkDungeonProgress() {
    let aliveEnemies = enemies.filter(e => !e.dead).length;
    if (aliveEnemies === 0 && (!boss || boss.dead)) {
        dungeonWave++; spawnWave();
    }
}

/* ================= DRAWING ================= */
/* ================= DRAWING UTILS ================= */
const arrows = [];

function spawnArrow(startX, startY, endX, endY) {
    arrows.push({ x: startX, y: startY, tx: endX, ty: endY, life: 30 });
}

// Add this into your gameLoop() to draw the flying arrows:
function updateArrows(ctx) {
    arrows.forEach((a, i) => {
        let dx = a.tx - a.x;
        let dy = a.ty - a.y;
        a.x += dx * 0.2;
        a.y += dy * 0.2;
        
        ctx.strokeStyle = "#fff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(a.x, a.y);
        ctx.lineTo(a.x + 10, a.y);
        ctx.stroke();

        a.life--;
        if (a.life <= 0 || Math.abs(dx) < 5) arrows.splice(i, 1);
    });
}
/* ================= DRAWING ================= */


// Helper to keep performAttack clean
function handleLoot(p, target) {
    let roll = Math.random();
    let drop = null;

    if (target === boss) {
        // Boss guaranteed high-tier
        drop = roll > 0.5 ? "Iron Plate" : "Iron Sword";
    } else {
        // Minion rare drops
        if (roll > 0.98) drop = "Iron helmet";
        else if (roll > 0.90) drop = "shitty shortbow";
        else if (roll > 0.85) drop = "Leather Tunic";
        else if (roll > 0.70) drop = "Paper Bag";
    }

    if (drop) {
        p.stats.inventory.push(drop);
        systemMessage(`âœ¨ ${p.name} looted: ${drop}!`);
    }
}
function drawEquipment(ctx, p, now) {
    if (p.dead) return;
    const isAttacking = p.activeTask === "attacking";
    const swing = Math.sin(now / 80) * 0.8;
    const pWeapon = p.stats.equippedWeapon;
    const lean = p.lean || 0;

    // --- 1. FISHING ROD & ARMS ---
    if (p.activeTask === "fishing" && p.area === "fishingpond") {
        let bob = Math.sin(now / 300) * 0.1;
        ctx.strokeStyle = p.color; ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x + (lean * 20), p.y - 15); 
        ctx.lineTo(p.x + 15, p.y - 10); 
        ctx.stroke();
        ctx.strokeStyle = "#8B4513"; ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(p.x + 12, p.y - 10);  
        ctx.lineTo(p.x + 50, p.y - 45 + (bob * 20)); 
        ctx.stroke();
        ctx.strokeStyle = "rgba(255,255,255,0.6)"; ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.x + 50, p.y - 45 + (bob * 20));
        ctx.quadraticCurveTo(p.x + 60, p.y, p.x + 70, p.y + 25);
        ctx.stroke();
        // Removed return so armor draws!
    }

    // --- 2. WEAPON (Equipped) ---
    if (pWeapon && ITEM_DB[pWeapon]) {
        const w = ITEM_DB[pWeapon];
        const isBow = pWeapon.toLowerCase().includes("shortbow");
        ctx.save();
        if (isAttacking) {
            ctx.translate(p.x + 10, p.y - 10);
            if (isBow) {
                ctx.strokeStyle = "#8B4513"; ctx.lineWidth = 2;
                let pull = Math.abs(Math.sin(now / 200)) * 10;
                ctx.beginPath(); ctx.arc(5, 0, 15, -Math.PI/2, Math.PI/2); ctx.stroke();
                ctx.strokeStyle = "#eee"; ctx.lineWidth = 1;
                ctx.beginPath(); ctx.moveTo(5, -15); ctx.lineTo(5 - pull, 0); ctx.lineTo(5, 15); ctx.stroke();
            } else {
                ctx.rotate(swing);
                ctx.strokeStyle = w.color; ctx.lineWidth = 3;
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(25, -5); ctx.stroke();
            }
        } else {
            ctx.translate(p.x - 5, p.y - 5);
            ctx.rotate(Math.PI / 1.2);
            ctx.strokeStyle = w.color; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(20, 0); ctx.stroke();
        }
        ctx.restore();
    }
    // --- 3. BARE HANDED PUNCH ---
    else if (isAttacking) {
        ctx.strokeStyle = p.color; ctx.lineWidth = 3;
        ctx.beginPath();
        let punchX = p.x + (Math.sin(now / 40) > 0 ? 22 : 12);
        ctx.moveTo(p.x + (lean * 20), p.y - 15);
        ctx.lineTo(punchX, p.y - 12);
        ctx.stroke();
    }

    // --- 4. ARMOR & HELMET ---
    if (p.stats.equippedArmor) drawArmor(ctx, p);
    
    // This now handles Wigs, Bags, and Iron Helmets correctly
    if (p.stats.equippedHelmet) {
        drawHelmet(ctx, p);
    }

    if (p.stats.equippedBoots) {
        drawBoots(ctx, p);
    }
}

function drawBoots(ctx, p) {
    const item = ITEM_DB[p.stats.equippedBoots];
    if (!item) return;

    const now = Date.now();
    // Re-calculate the walk offset so boots match the leg position
    let walk = (p.targetX !== null) ? Math.sin(now/100) * 10 : 0;

    ctx.save();
    ctx.fillStyle = item.color;
    ctx.strokeStyle = "#000";
    ctx.lineWidth = 1;

    // Left Boot
    const leftFootX = p.x - 10 - walk;
    const footY = p.y + 25;
    ctx.fillRect(leftFootX - 4, footY - 2, 8, 5); // Foot base
    ctx.strokeRect(leftFootX - 4, footY - 2, 8, 5);
    ctx.fillRect(leftFootX - 2, footY - 6, 4, 5); // Ankle part
    
    // Right Boot
    const rightFootX = p.x + 10 + walk;
    ctx.fillRect(rightFootX - 4, footY - 2, 8, 5);
    ctx.strokeRect(rightFootX - 4, footY - 2, 8, 5);
    ctx.fillRect(rightFootX - 2, footY - 6, 4, 5);

    ctx.restore();
}
function drawArmor(ctx, p) {
    const item = ITEM_DB[p.stats.equippedArmor];
    if (!item) return;

    const lean = p.lean || 0;
    const headX = p.x + (lean * 20);

    ctx.save();
    
    // 1. Setup Path for the "Vest"
    ctx.beginPath();
    ctx.moveTo(headX - 7, p.y - 18); // Shoulder left
    ctx.lineTo(headX + 7, p.y - 18); // Shoulder right
    ctx.lineTo(p.x + 7, p.y + 8);    // Waist right
    ctx.lineTo(p.x - 7, p.y + 8);    // Waist left
    ctx.closePath();

    // 2. FILL the armor (Solid Color)
    ctx.fillStyle = item.color;
    ctx.globalAlpha = 0.8; // Slight transparency so it looks "worn"
    ctx.fill();

    // 3. STROKE the armor (Dark Border for definition)
    ctx.globalAlpha = 1.0;
    ctx.strokeStyle = "#000"; // Black outline
    ctx.lineWidth = 1;
    ctx.stroke();

    // 4. SHINY HIGHLIGHT (If it's high tier)
    if (item.color === "#eee" || item.color === "#aaa") {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
        ctx.lineWidth = 2;
        ctx.beginPath(); 
        ctx.moveTo(headX - 3, p.y - 15); 
        ctx.lineTo(p.x - 3, p.y + 2); 
        ctx.stroke();
    }

    ctx.restore();
}
function drawHelmet(ctx, p) {
    const item = ITEM_DB[p.stats.equippedHelmet];
    if (!item) return;

    const leanOffset = (p.lean || 0) * 20;
    const hX = p.x + leanOffset;
    const hY = p.y - 30; // Center of head

    ctx.save();
    ctx.lineWidth = 2;

    // Convert to lowercase for the check to prevent "Paper Bag" vs "paper bag" bugs
    const helmetName = p.stats.equippedHelmet.toLowerCase();

    if (helmetName === "paper bag") {
        ctx.fillStyle = "#d2b48c"; // Tan paper color
        ctx.strokeStyle = "#000";   // Solid black for Retro HUD style
        ctx.fillRect(hX - 12, hY - 14, 24, 26);
        ctx.strokeRect(hX - 12, hY - 14, 24, 26);
        
        // Eye holes
        ctx.fillStyle = "#111";
        ctx.fillRect(hX - 7, hY - 4, 5, 5);
        ctx.fillRect(hX + 2, hY - 4, 5, 5);
        
        // Crinkle lines
        ctx.strokeStyle = "rgba(0,0,0,0.2)";
        ctx.beginPath(); ctx.moveTo(hX - 12, hY + 5); ctx.lineTo(hX + 12, hY + 8); ctx.stroke();
    } 
    else if (helmetName === "wig") {
        ctx.fillStyle = item.color || "#ffff00";
        ctx.beginPath();
        ctx.arc(hX, hY - 5, 14, Math.PI, 0);
        ctx.arc(hX - 8, hY, 8, 0, Math.PI * 2);
        ctx.arc(hX + 8, hY, 8, 0, Math.PI * 2);
        ctx.fill();
    }
    else if (helmetName === "iron helmet") {
        ctx.fillStyle = "#aaa";
        ctx.strokeStyle = "#000";
        ctx.beginPath();
        ctx.arc(hX, hY, 12, Math.PI, 0); 
        ctx.lineTo(hX + 12, hY + 10);
        ctx.lineTo(hX - 12, hY + 10);
        ctx.closePath();
        ctx.fill();
        ctx.stroke();
        
        // Visor slit
        ctx.strokeStyle = "#222";
        ctx.beginPath(); ctx.moveTo(hX - 8, hY + 4); ctx.lineTo(hX + 8, hY + 4); ctx.stroke();
    }

    ctx.restore();
}
function drawStickman(ctx, p) {
    if (p.area !== viewArea) return;
    updatePhysics(p); 
    const now = Date.now();
    let lean = p.lean || 0;

    // Death handling (Original)
    if (p.dead) {
        ctx.fillStyle = "rgba(200, 0, 0, 0.6)";
        ctx.beginPath(); ctx.ellipse(p.x, p.y + 20, 25, 10, 0, 0, Math.PI * 2); ctx.fill();
        ctx.textAlign = "center"; ctx.fillStyle = "#555";
        ctx.fillText("CORPSE", p.x, p.y + 10);
        return;
    }

    // --- DANCE ANIMATION OFFSETS ---
    let bodyY = 0;
    let armMove = 0;
    let legMove = 0;
    const isDancing = p.activeTask === "dancing";

    if (isDancing) {
        if (p.danceStyle === 1) bodyY = Math.sin(now / 100) * 8; // The Squat
        if (p.danceStyle === 2) armMove = Math.sin(now / 50) * 20; // The Flail
        if (p.danceStyle === 3) lean = Math.sin(now / 200) * 0.6; // The Lean
    }

    ctx.strokeStyle = p.color; ctx.lineWidth = 3;
    
    // 1. Head
    const headX = p.x + (lean * 20);
    const headY = p.y - 30 + bodyY;
    ctx.beginPath(); ctx.arc(headX, headY, 10, 0, Math.PI * 2); ctx.stroke();

    // Face (Original)
    ctx.fillStyle = p.color;
    ctx.fillRect(headX + 2, headY - 3, 2, 2);
    ctx.fillRect(headX + 6, headY - 3, 2, 2);
    ctx.beginPath(); ctx.arc(headX + 4, headY + 2, 3, 0, Math.PI); ctx.stroke();
    
    // 2. Torso
    ctx.beginPath(); ctx.moveTo(headX, headY + 10); ctx.lineTo(p.x, p.y + 10 + bodyY); ctx.stroke();

    // 3. ARMS
    const isAttacking = p.activeTask === "attacking";
    const isFishing = p.activeTask === "fishing" && p.area === "fishingpond";

    // Draw idle/dance arms if not attacking/fishing
    if (!isAttacking && !isFishing && !p.stats.equippedWeapon) {
        ctx.beginPath(); 
        // Left Arm
        ctx.moveTo(headX, headY + 15); 
        ctx.lineTo(p.x - 18 + (lean * 10), p.y + 3 + bodyY + armMove); 
        // Right Arm
        ctx.moveTo(headX, headY + 15); 
        ctx.lineTo(p.x + 18 + (lean * 30), p.y + 3 + bodyY - armMove); 
        ctx.stroke();
    }

    // 4. Legs
    let walk = (p.targetX !== null) ? Math.sin(now/100) * 10 : 0;
    ctx.beginPath(); 
    ctx.moveTo(p.x, p.y + 10 + bodyY); 
    ctx.lineTo(p.x - 10 - walk, p.y + 25); 
    ctx.moveTo(p.x, p.y + 10 + bodyY); 
    ctx.lineTo(p.x + 10 + walk, p.y + 25); 
    ctx.stroke();

    // 5. Equipment
    drawEquipment(ctx, p, now);

    // HP Bar & Name (Original)
    ctx.fillStyle = "#444"; ctx.fillRect(p.x - 20, p.y - 55, 40, 4);
    ctx.fillStyle = "#0f0"; ctx.fillRect(p.x - 20, p.y - 55, 40 * (p.hp / p.maxHp), 4);
    ctx.fillStyle = "#fff"; ctx.font = "12px monospace"; ctx.textAlign = "center";
    ctx.fillText(p.name, p.x, p.y + 40);
}
function drawScenery(ctx) {
    const now = Date.now();

    if (viewArea === "home") {
        // --- CHILL HOME VIBES ---
        // Draw a simple Floor/Ground
        ctx.fillStyle = "#252545";
        ctx.fillRect(0, 475, c.width, 125);

        // Draw some "Stars" or "Dust" in the air
        ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
        for(let i=0; i<10; i++) {
            let x = (i * 100 + (now/50)) % c.width;
            ctx.fillRect(x, 100 + (i*20), 2, 2);
        }

    } else if (viewArea === "fishingpond") {
        // --- LAKE / WATER VIBES ---
        // The Shore
        ctx.fillStyle = "#1a2e1a";
        ctx.fillRect(0, 475, 250, 125); // Land on the left

        // The Water
        ctx.fillStyle = "#0a2e3a";
        ctx.fillRect(250, 485, c.width - 250, 115);

        // Water Ripples
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 2;
        for(let i=0; i<5; i++) {
            let rx = 300 + (i * 120);
            let ry = 520 + (Math.sin(now/500 + i) * 10);
            ctx.beginPath(); ctx.moveTo(rx, ry); ctx.lineTo(rx + 40, ry); ctx.stroke();
        }

    } else if (viewArea === "dungeon") {
        // --- GRITTY DUNGEON VIBES ---
        // Floor
        ctx.fillStyle = "#110505";
        ctx.fillRect(0, 475, c.width, 125);

        // Cracks in the wall/back
        ctx.strokeStyle = "#2a1010";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(100, 0); ctx.lineTo(120, 100); ctx.lineTo(80, 200);
        ctx.moveTo(600, 0); ctx.lineTo(580, 150); ctx.lineTo(620, 300);
        ctx.stroke();

        // Spikes/Pillars
        ctx.fillStyle = "#1d0a0a";
        ctx.beginPath(); ctx.moveTo(200, 475); ctx.lineTo(225, 300); ctx.lineTo(250, 475); ctx.fill();
    }
}
function gameLoop() {
    // 1. Background
    ctx.fillStyle = backgrounds[viewArea];
    ctx.fillRect(0, 0, c.width, c.height);
    // 1.5 NEW: Draw Area Props
    drawScenery(ctx);

    // 2. Enemy UI Updates
    let enemyText = "";
    if (viewArea === "dungeon") {
        enemies.forEach(e => { if(!e.dead) enemyText += `Enemy: ${e.hp}hp<br>`; });
        if (boss && !boss.dead) enemyText += `<b>BOSS: ${boss.hp}hp</b>`;
    }
    document.getElementById("enemyUI").innerHTML = enemyText;

	// --- Inside Section 3 of your gameLoop ---
	const now = Date.now(); 

	Object.values(players).forEach(p => {
		// 1. TIMEOUT CHECK (Universal for all tasks)
		if (p.activeTask && p.taskEndTime && now > p.taskEndTime) {
			systemMessage(`${p.name} stopped ${p.activeTask} (Idle timeout).`);
			p.activeTask = null;
			p.targetX = null;
			p.danceStyle = 0; // Reset dance
		}

		// 2. MOVEMENT LOGIC (Original)
		if (p.targetX !== null && p.targetX !== undefined) {
			let dx = p.targetX - p.x;
			if (Math.abs(dx) > 5) {
				p.x += dx * 0.1;
				p.lean = dx > 0 ? 0.2 : -0.2;
			} else {
				p.lean = 0;
				if (p.activeTask !== "attacking") p.targetX = null;
			}
		}

		// 3. ATTACK TIMING LOGIC (Original)
		if (p.activeTask === "attacking" && !p.dead) {
			let weapon = ITEM_DB[p.stats.equippedWeapon];
			let attackSpeed = weapon?.speed || 700; 
			if (!p.lastAttackTime) p.lastAttackTime = 0;
			if (now - p.lastAttackTime > attackSpeed) {
				performAttack(p);
				p.lastAttackTime = now;
			}
		}

		// 4. DRAW
		drawStickman(ctx, p);
	});
	updateArrows(ctx);

    // 4. Draw Dungeon Entities
    if (viewArea === "dungeon") {
        enemies.forEach(e => {
            if (!e.dead) {
                ctx.fillStyle = "#f00"; ctx.fillRect(e.x, e.y, 20, 20);
                ctx.fillStyle = "#fff"; ctx.textAlign = "center";
                ctx.fillText(e.hp, e.x + 10, e.y - 5);
            }
        });
        if (boss && !boss.dead) { 
            ctx.fillStyle = "#ff00ff"; ctx.fillRect(boss.x, boss.y, 50, 50); 
            ctx.fillStyle = "#fff"; ctx.fillText(boss.hp, boss.x + 25, boss.y - 5);
        }
    }

    // 5. Draw Floating Text
    floaters.forEach((f, i) => {
        ctx.fillStyle = f.color; ctx.globalAlpha = f.life / 100;
        ctx.textAlign = "center";
        ctx.fillText(f.text, f.x, f.y); f.y -= 1; f.life--;
        if (f.life <= 0) floaters.splice(i, 1);
    });
    ctx.globalAlpha = 1;

    handleTooltips();
    requestAnimationFrame(gameLoop);
}

/* ================= CHAT COMMANDS ================= */
/* ================= COMMAND FUNCTIONS ================= */
function cmdDance(p, user) {
    if (p.dead) return;
    p.activeTask = "dancing";
    p.danceStyle = Math.floor(Math.random() * 3) + 1; // Pick dance 1, 2, or 3
    p.taskEndTime = Date.now() + (15 * 60 * 1000); // 15m duration
    systemMessage(`${user} is busting a move! (Dance Style ${p.danceStyle})`);
}
// --- COMBAT & TASKS ---
function cmdAttack(p, user) {
    if (p.activeTask === "attacking") { 
        systemMessage(`${user}: Already attacking.`); 
        return; 
    }
    
    p.activeTask = "attacking";
    // Keep your 15-minute timer logic
    p.taskEndTime = Date.now() + (15 * 60 * 1000); 
    // Reset attack cooldown so they hit immediately
    p.lastAttackTime = 0; 
    
    systemMessage(`${user} started attacking (15m idle)`);
}

function cmdHeal(p, args) {
    let target = players[args[1]];
    if (target && target.area === p.area && !target.dead) {
        let amt = 10 + (p.stats.healLevel * 5);
        target.hp = Math.min(target.maxHp, target.hp + amt);
        spawnFloater(`+${amt} HP`, target.x, target.y - 40, "#0f0");
        p.stats.healXP += 15;
        if (p.stats.healXP >= xpNeeded(p.stats.healLevel)) {
            p.stats.healLevel++; p.stats.healXP = 0; 
            systemMessage(`${p.name} HEAL UP! (Lv ${p.stats.healLevel})`);
        }
        saveStats(p);
    }
}

function cmdFish(p, user) {
    if (p.area !== "fishingpond") { systemMessage(`${user}: Go to fishingpond first.`); return; }
    if (p.activeTask === "fishing") { systemMessage(`${user}: Already fishing.`); return; }
    p.activeTask = "fishing";
    p.taskEndTime = Date.now() + TASK_DURATION;
    systemMessage(`${user} started fishing (15m idle)`);
}
// --- SOCIAL ---
function cmdMingle(p, user, args) {
    if (p.area !== "home") return;
    let target = players[args[1]] || Object.values(players).find(pl => pl.name !== user && pl.area === "home" && !pl.dead);
    if (target) { 
        p.mingleTarget = target; 
        setTimeout(() => { p.mingleTarget = null; }, 5000); 
    }
}


function cmdEquip(p, args) {
    // 1. Join args and normalize to lowercase for easy searching
    let inputName = args.slice(1).join(" ").toLowerCase();
    
    // 2. Find the item in the inventory (case-insensitive)
    let invItem = p.stats.inventory.find(i => i.toLowerCase() === inputName);
    
    if (!invItem) {
        systemMessage(`${p.name}: You don't have "${args.slice(1).join(" ")}" in your inventory.`);
        return;
    }

    // 3. Find the item in the ITEM_DB to get its stats
    // We search the DB keys to match the inventory item
    let dbKey = Object.keys(ITEM_DB).find(k => k.toLowerCase() === invItem.toLowerCase());
    let itemData = ITEM_DB[dbKey];

    if (!itemData) {
        systemMessage(`System Error: ${invItem} has no stats in ITEM_DB.`);
        return;
    }

    // 4. Equip based on type
	if (itemData.type === "weapon") {
		p.stats.equippedWeapon = dbKey;
		systemMessage(`${p.name} equipped ${dbKey}!`);
	} else if (itemData.type === "armor") {
		p.stats.equippedArmor = dbKey;
		systemMessage(`${p.name} put on ${dbKey}!`);
	} else if (itemData.type === "helmet") {
		p.stats.equippedHelmet = dbKey; // New slot!
		systemMessage(`${p.name} is wearing ${dbKey}!`);
	} else if (itemData.type === "boots") { // <--- ADD THIS
        p.stats.equippedBoots = dbKey;
        systemMessage(`${p.name} laced up ${dbKey}!`);
    }
    saveStats(p);
}
function cmdUnequip(p, args) {
    const target = args[1] ? args[1].toLowerCase() : "all";
    let message = "";

    if (target === "weapon" || target === "all") {
        p.stats.equippedWeapon = null;
        message = "weapon";
    }
    if (target === "armor" || target === "armour" || target === "all") {
        p.stats.equippedArmor = null;
        message = message ? "items" : "armor";
    }
    if (target === "helmet" || target === "all") {
        p.stats.equippedHelmet = null;
        message = message ? "items" : "helmet";
    }
    if (target === "boots" || target === "all") {
        p.stats.equippedBoots = null;
        message = message ? "items" : "boots";
    }

    if (message) {
        systemMessage(`${p.name} unequipped ${target === "all" ? "everything" : "their " + target}.`);
        saveStats(p);
    } else {
        systemMessage(`${p.name}: Invalid slot. Use !unequip (weapon/armor/helmet/boots/all)`);
    }
}
function cmdInventory(p, user, args) {
    let filter = args[1] ? args[1].toLowerCase() : "all";
    let items = p.stats.inventory;
    let result = [];

    // --- 1. ORIGINAL FILTER LOGIC ---
    if (filter === "weapons") result = items.filter(i => ITEM_DB[i]?.type === "weapon");
    else if (filter === "armor" || filter === "armour") {
        result = items.filter(i => ["armor", "helmet", "boots"].includes(ITEM_DB[i]?.type));
    } 
    else if (filter === "boots") result = items.filter(i => ITEM_DB[i]?.type === "boots");
    else if (filter === "helmets") result = items.filter(i => ITEM_DB[i]?.type === "helmet");
    else if (filter === "fish") result = items.filter(i => i.includes("kg"));
    else if (filter === "tools") result = items.filter(i => ITEM_DB[i]?.type === "tool" || i === "Fishing Rod");
    else result = items;

    if (result.length === 0) {
        systemMessage(`${user}'s ${filter} inventory is empty.`);
        return;
    }

    // --- 2. NEW COLUMN & STACKING LOGIC ---
    let counts = {};
    let fishWeight = 0;
    let fishCount = 0;

    result.forEach(item => {
        if (item.includes("kg")) {
            // Extract weight from string like "2.5kg Bass"
            let weight = parseFloat(item.split("kg")[0]) || 0;
            fishWeight += weight;
            fishCount++;
        } else {
            // Stack gear/items
            counts[item] = (counts[item] || 0) + 1;
        }
    });

    // --- 3. DISPLAY FORMATTING ---
    // Header mimicking the Old HUD style
    let output = `\n[ ${user.toUpperCase()}'S ${filter.toUpperCase()} ]`;
    
    // Add Fish Summary if any are in the filtered results
    if (fishCount > 0) {
        output += `\n> Fish x${fishCount} (Total: ${fishWeight.toFixed(2)}kg)`;
    }

    // Add Stacked Items in a column
    for (let [name, qty] of Object.entries(counts)) {
        output += `\n> ${name} ${qty > 1 ? "x" + qty : ""}`;
    }

    systemMessage(output);
}
function cmdSell(p, args) {
    if (p.stats.inventory.length === 0) {
        systemMessage(`${p.name}: Your inventory is empty.`);
        return;
    }

    let target = args.slice(1).join(" ").toLowerCase();
    let totalGold = 0;
    let itemsRemoved = 0;

    if (target === "fish") {
        // Sell all fish
        p.stats.inventory = p.stats.inventory.filter(item => {
            if (item.includes("kg")) {
                let weight = parseFloat(item.split("kg")[0]);
                totalGold += Math.floor(weight * 10); // 10 gold per kg
                itemsRemoved++;
                return false; // Remove from inventory
            }
            return true; // Keep in inventory
        });
    } else {
        // Sell specific item
        let index = p.stats.inventory.findIndex(i => i.toLowerCase() === target);
        if (index !== -1) {
            let itemName = p.stats.inventory[index];
            let itemData = ITEM_DB[itemName];
            
            // Default price 50g for gear, or use a .value property if it exists
            totalGold = itemData?.value || 50; 
            p.stats.inventory.splice(index, 1);
            itemsRemoved = 1;
        }
    }

    if (itemsRemoved > 0) {
        p.stats.gold = (p.stats.gold || 0) + totalGold;
        systemMessage(`${p.name} sold ${itemsRemoved} item(s) for ${totalGold} gold!`);
        saveStats(p);
    } else {
        systemMessage(`${p.name}: Could not find "${target}" to sell. Try "!sell fish" or "!sell [item name]".`);
    }
}
// --- STATS & INFO ---
function cmdShowStats(user, args) {
    let targetName = args[1] ? args[1].toLowerCase() : user.toLowerCase();
    let targetData = null;
    let finalName = "";

    let onlinePlayer = Object.values(players).find(pl => pl.name.toLowerCase() === targetName);
    if (onlinePlayer) {
        targetData = onlinePlayer.stats;
        finalName = onlinePlayer.name;
    } else {
        let saved = localStorage.getItem("rpg_" + targetName);
        if (saved) {
            targetData = JSON.parse(saved);
            finalName = targetName;
        }
    }

    if (targetData) {
        systemMessage(`${finalName} - CB: ${targetData.combatLevel} | ATK: ${targetData.attackLevel} | FISH: ${targetData.fishLevel} | HEAL: ${targetData.healLevel}`);
    } else {
        systemMessage(`System: Could not find stats for ${targetName}`);
    }
}

function cmdTopStats() {
    let allStats = [];
    for (let i = 0; i < localStorage.length; i++) {
        let key = localStorage.key(i);
        if (key.startsWith("rpg_")) {
            let name = key.replace("rpg_", "");
            try {
                let data = JSON.parse(localStorage.getItem(key));
                allStats.push({ name, cb: data.combatLevel || 1 });
            } catch(e) {}
        }
    }
    allStats.sort((a, b) => b.cb - a.cb);
    let top5 = allStats.slice(0, 5).map((s, i) => `#${i+1} ${s.name}(Lv${s.cb})`).join(" | ");
    systemMessage(`TOP PLAYERS: ${top5}`);
}
/* ================= THE COMFY ROUTER ================= */
ComfyJS.onChat = (user, msg, flags, extra) => {
    let p = getPlayer(user, extra.userColor);
    let args = msg.split(" ");
    let cmd = args[0].toLowerCase();

    // Combat & Tasks
    if (cmd === "attack") cmdAttack(p, user);
    if (cmd === "fish")   cmdFish(p, user);
    if (cmd === "heal")   cmdHeal(p, args);
    
    // Movement
    if (cmd === "travel")  movePlayer(p, args[1]);
    if (cmd === "home")    movePlayer(p, "home");
    if (cmd === "dungeon") movePlayer(p, "dungeon");
    if (cmd === "join")    joinDungeonQueue(p);
    if (cmd === "dance") cmdDance(p, user);
    // Stats & Inventory
    if (cmd === "stats")    cmdShowStats(user, args);
    if (cmd === "topstats") cmdTopStats();
	if (cmd === "equip") cmdEquip(p, args);
	if (cmd === "unequip") cmdUnequip(p, args);
    if (cmd === "inventory") cmdInventory(p, user, args);
	if (cmd === "sell") cmdSell(p, args);
    // Status
    if (cmd === "mingle") cmdMingle(p, user, args);
    if (cmd === "respawn" && p.dead) { 
        p.dead = false; p.hp = p.maxHp; 
        systemMessage(`${p.name} returned to life!`); 
    }

    // Admin Controls
    if (flags.broadcaster || flags.mod) {
        if (cmd === "showhome") { viewArea = "home"; document.getElementById("areaDisplay").textContent = "StickenFallv2.1.3 - VIEWING: HOME"; }
        if (cmd === "showdungeon") { viewArea = "dungeon"; document.getElementById("areaDisplay").textContent = "StickenFallv2.1.3 - VIEWING: DUNGEON"; }
        if (cmd === "showfishing") { viewArea = "fishingpond"; document.getElementById("areaDisplay").textContent = "StickenFallv2.1.3 - VIEWING: FISHING POND"; }
    }
};
setInterval(() => {
    if (!dungeonActive) return;
    let dwellers = Object.values(players).filter(p => p.area === "dungeon" && !p.dead);
    if (dwellers.length === 0) return;
    enemies.forEach(e => {
        if (e.dead) return;
        let target = dwellers[Math.floor(Math.random() * dwellers.length)];
        target.hp -= 5; spawnFloater(`-5`, target.x, target.y - 40, "#f00");
        if (target.hp <= 0) { target.hp = 0; target.dead = true; }
    });
}, 4000);

ComfyJS.Init("jaedraze");
gameLoop();
</script>


<!-- function drawEquipment(ctx, p, now) {
    if (p.dead) return;

    if (p.activeTask === "fishing" && p.area === "fishingpond") {
        ctx.strokeStyle = "#8B4513"; 
        ctx.lineWidth = 2;
        let bob = Math.sin(now / 300) * 0.1;
        
        ctx.beginPath();
        ctx.moveTo(p.x + 10, p.y - 10); 
        ctx.lineTo(p.x + 40, p.y - 40 + (bob * 20)); 
        ctx.stroke();

        ctx.strokeStyle = "rgba(255,255,255,0.5)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(p.x + 40, p.y - 40 + (bob * 20));
        ctx.quadraticCurveTo(p.x + 50, p.y, p.x + 60, p.y + 20);
        ctx.stroke();
    }

    if (p.activeTask === "attacking") {

        ctx.strokeStyle = p.stats.attackLevel > 10 ? "#0ff" : "#ccc"; 
        ctx.lineWidth = 3;
        
        let swing = Math.sin(now / 150) * 0.8;
        
        ctx.save();
        ctx.translate(p.x + 12, p.y - 10);
        ctx.rotate(swing);
        
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(25, -5); 
        ctx.stroke();

        ctx.strokeStyle = "#aa8800";
        ctx.beginPath(); ctx.moveTo(5, -8); ctx.lineTo(5, 8); ctx.stroke();
        
        ctx.restore();
    }
}
 -->

</body>
</html>